<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../css/styles.css"> <!-- Base styles (optional) -->
    <style>
        body {
            margin: 0;
            padding: 0;
            background: transparent;
            /* Transparent by default for content-only mode */
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }

        #editor {
            flex: 1;
            padding: 10px;
            background: transparent;
            /* Transparent for content-only mode */
            color: var(--node-text, #333);
            border: none;
            outline: none;
            font-size: 14px;
            resize: none;
            overflow-y: auto;
            min-height: 100px;
        }

        /* Normal mode (non-content-only) */
        body.has-background #editor {
            background: #ffffff;
            color: #333;
        }

        /* Night mode in normal  mode */
        body.night-mode.has-background #editor {
            background: #2b2b2b;
            color: #e0e0e0;
        }
    </style>
</head>

<body>
    <textarea id="editor" placeholder="Type something..."></textarea>

    <!-- SDK -->
    <script src="../../js/MosaicNode.js"></script>
    <script>
        const editor = document.getElementById('editor');

        // Detect if parent has night mode
        function detectParentNightMode() {
            try {
                // Check if parent window has night-mode class
                if (window.parent && window.parent.document && window.parent.document.body) {
                    const parentBody = window.parent.document.body;
                    const isNightMode = parentBody.classList.contains('night-mode');

                    if (isNightMode) {
                        document.body.classList.add('night-mode');
                    } else {
                        document.body.classList.remove('night-mode');
                    }

                    // Watch for changes to parent's night mode
                    const observer = new MutationObserver(() => {
                        if (parentBody.classList.contains('night-mode')) {
                            document.body.classList.add('night-mode');
                        } else {
                            document.body.classList.remove('night-mode');
                        }
                    });

                    observer.observe(parentBody, {
                        attributes: true,
                        attributeFilter: ['class']
                    });
                }
            } catch (e) {
                // Cross-origin restriction, ignore
                console.log('Cannot detect parent night mode (cross-origin)');
            }
        }

        // Detect if node is in content-only mode (check parent node)
        function detectContentOnlyMode() {
            try {
                if (window.parent && window.parent.document) {
                    // Find the node element containing this iframe
                    const iframes = window.parent.document.querySelectorAll('iframe');
                    for (let iframe of iframes) {
                        if (iframe.contentWindow === window) {
                            const node = iframe.closest('.node');
                            if (node && !node.classList.contains('content-only-mode')) {
                                document.body.classList.add('has-background');
                            } else {
                                document.body.classList.remove('has-background');
                            }

                            // Watch for content-only mode changes
                            const observer = new MutationObserver(() => {
                                if (node && !node.classList.contains('content-only-mode')) {
                                    document.body.classList.add('has-background');
                                } else {
                                    document.body.classList.remove('has-background');
                                }
                            });

                            if (node) {
                                observer.observe(node, {
                                    attributes: true,
                                    attributeFilter: ['class']
                                });
                            }
                            break;
                        }
                    }
                }
            } catch (e) {
                // Default to has-background if we can't detect
                document.body.classList.add('has-background');
            }
        }

        // Initialize
        detectParentNightMode();
        detectContentOnlyMode();

        // Initialize
        window.Mosaic.onDataLoaded = (data) => {
            if (data.content) {
                // Check if this is legacy content with images
                if (data.hasLegacyImages) {
                    // Convert textarea to div for displaying HTML content with images
                    editor.style.display = 'none';

                    const contentDiv = document.createElement('div');
                    contentDiv.id = 'legacy-content';
                    contentDiv.innerHTML = data.content;
                    contentDiv.style.padding = '10px';
                    contentDiv.style.overflow = 'auto';
                    contentDiv.style.flex = '1';
                    contentDiv.style.color = 'var(--node-text, #333)';

                    // Apply night mode if needed
                    if (document.body.classList.contains('night-mode')) {
                        contentDiv.style.color = '#e0e0e0';
                    }

                    document.body.appendChild(contentDiv);
                    console.log('[TextNode] Loaded legacy content with images');
                } else {
                    editor.value = data.content;
                    // Prime the SDK cache for auto-refresh
                    window.Mosaic.send({ type: 'text', value: data.content });
                }
            }
        };

        // Auto-save AND Send on input
        editor.addEventListener('input', () => {
            const content = editor.value;
            window.Mosaic.saveData({ content: content });
            window.Mosaic.send({ type: 'text', value: content });
        });

        // Text node is OUTPUT-ONLY - removed input listener
        // Other nodes can send data but text nodes only produce output

        // Optional: Auto-resize request (simple version)
        editor.addEventListener('mouseup', () => {
            // Example: if we wanted to auto-grow
            // window.Mosaic.resize(document.body.scrollWidth, document.body.scrollHeight);
        });

    </script>
</body>

</html>