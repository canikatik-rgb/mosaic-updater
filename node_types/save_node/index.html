<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Save Node</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            background: #1e1e1e;
            color: #eee;
            font-family: 'Inter', -apple-system, sans-serif;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: #252525;
            border-bottom: 1px solid #333;
            gap: 10px;
        }

        .select-all {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            cursor: pointer;
        }

        .select-all input[type="checkbox"] {
            width: 14px;
            height: 14px;
            cursor: pointer;
        }

        .format-select {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .format-select label {
            font-size: 11px;
            color: #888;
        }

        .format-select select {
            background: #333;
            border: 1px solid #444;
            color: #fff;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
        }

        .preview-grid {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-content: start;
        }

        /* Preview items with proper aspect ratio */
        .preview-item {
            position: relative;
            background: #2a2a2a;
            border: 2px solid #333;
            border-radius: 6px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.15s ease;
            flex-shrink: 0;
        }

        .preview-item:hover {
            border-color: #555;
        }

        .preview-item.selected {
            border-color: #0d99ff;
            box-shadow: 0 0 0 2px rgba(13, 153, 255, 0.3);
        }

        .preview-item .checkbox {
            position: absolute;
            top: 6px;
            left: 6px;
            width: 18px;
            height: 18px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #666;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        .preview-item.selected .checkbox {
            background: #0d99ff;
            border-color: #0d99ff;
        }

        .preview-item .checkbox i {
            color: white;
            font-size: 10px;
            opacity: 0;
        }

        .preview-item.selected .checkbox i {
            opacity: 1;
        }

        .preview-content {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            background: #333;
        }

        .preview-content img,
        .preview-content canvas {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .type-badge {
            position: absolute;
            bottom: 4px;
            right: 4px;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            color: #aaa;
            text-transform: uppercase;
        }

        .source-name {
            position: absolute;
            bottom: 4px;
            left: 4px;
            right: 40px;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            color: #ccc;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            cursor: text;
        }

        .source-name:focus {
            outline: 1px solid #0d99ff;
            background: rgba(0, 0, 0, 0.9);
        }

        .empty-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #555;
            gap: 10px;
            width: 100%;
        }

        .empty-state i {
            font-size: 32px;
        }

        .empty-state span {
            font-size: 12px;
        }

        .footer {
            padding: 10px 12px;
            background: #252525;
            border-top: 1px solid #333;
        }

        .export-btn {
            width: 100%;
            background: #0d99ff;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .export-btn:hover {
            background: #0b7fd4;
        }

        .export-btn:disabled {
            background: #444;
            cursor: not-allowed;
        }

        .export-btn .spinner {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .status {
            font-size: 11px;
            color: #666;
            text-align: center;
            margin-top: 6px;
            min-height: 14px;
        }

        .status.error {
            color: #ff6b6b;
        }

        .status.success {
            color: #51cf66;
        }
    </style>
</head>

<body>
    <div class="header">
        <label class="select-all">
            <input type="checkbox" id="selectAll">
            <span>Select All</span>
        </label>
        <div class="format-select">
            <label>Format:</label>
            <select id="formatSelect">
                <option value="png">PNG</option>
                <option value="jpg">JPG</option>
                <option value="pdf">PDF</option>
                <option value="svg">SVG</option>
                <option value="html">HTML</option>
                <option value="json">JSON</option>
                <option value="txt">TXT</option>
            </select>
        </div>
    </div>

    <div class="preview-grid" id="previewGrid">
        <div class="empty-state" id="emptyState">
            <i class="fas fa-plug"></i>
            <span>Connect nodes to export</span>
        </div>
    </div>

    <div class="footer">
        <button class="export-btn" id="exportBtn" disabled>
            <i class="fas fa-download"></i>
            <span>Export Selected (0)</span>
        </button>
        <div class="status" id="status"></div>
    </div>

    <script src="../../js/MosaicNode.js"></script>
    <script>
        let inputs = [];
        let format = 'png';

        const grid = document.getElementById('previewGrid');
        const emptyState = document.getElementById('emptyState');
        const formatSelect = document.getElementById('formatSelect');
        const selectAllCheckbox = document.getElementById('selectAll');
        const exportBtn = document.getElementById('exportBtn');
        const statusDiv = document.getElementById('status');

        // Max thumbnail height in the grid
        const MAX_THUMB_HEIGHT = 100;

        window.Mosaic.on('input', (data, sourceId) => {
            console.log('[SaveNode] Input received:', data, 'sourceId:', sourceId);

            // SDP Unpack
            const payload = data.payload || {};
            const type = data.type;
            const value = payload.value || data.value;
            const content = payload.content || data.content;
            const width = payload.width || data.width;
            const height = payload.height || data.height;
            const slides = payload.slides || data.slides;

            // Prefer payload source title if available
            let sourceTitle = payload.sourceTitle || data.sourceTitle || data.name || 'Content';

            // Handle Presentation Node
            if (type === 'presentation' && slides && Array.isArray(slides)) {
                inputs = inputs.filter(i => !i.sourceId.startsWith(sourceId + '-slide-'));

                slides.forEach((slide, index) => {
                    const slideId = `${sourceId}-slide-${index}`;
                    const existingIndex = inputs.findIndex(i => i.sourceId === slideId);

                    const inputObj = {
                        id: `input-${Date.now()}-${index}`,
                        sourceId: slideId,
                        sourceTitle: slide.name || `Slide ${index + 1}`,
                        customName: null,
                        data: {
                            type: 'html',
                            isCanvas: true,
                            value: slide.content,
                            width: slide.width,
                            height: slide.height
                        },
                        selected: true,
                        type: 'html'
                    };

                    if (existingIndex >= 0) {
                        inputObj.id = inputs[existingIndex].id;
                        inputObj.selected = inputs[existingIndex].selected;
                        inputObj.customName = inputs[existingIndex].customName;
                        inputs[existingIndex] = inputObj;
                    } else {
                        inputs.push(inputObj);
                    }
                });

                renderPreviews();
                updateExportButton();
                return;
            }

            const existingIndex = inputs.findIndex(i => i.sourceId === sourceId);

            const inputObj = {
                id: `input-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
                sourceId: sourceId,
                sourceTitle: sourceTitle,
                customName: null,
                data: data,
                selected: true,
                type: detectContentType(data)
            };

            if (existingIndex >= 0) {
                inputObj.id = inputs[existingIndex].id;
                inputObj.selected = inputs[existingIndex].selected;
                inputObj.customName = inputs[existingIndex].customName;
                inputs[existingIndex] = inputObj;
            } else {
                inputs.push(inputObj);
            }

            renderPreviews();
            updateExportButton();
        });

        window.Mosaic.on('disconnect', (sourceId) => {
            inputs = inputs.filter(i => i.sourceId !== sourceId && !i.sourceId.startsWith(sourceId + '-slide-'));
            renderPreviews();
            updateExportButton();
        });

        function detectContentType(data) {
            if (!data) return 'unknown';
            if (data.type === 'image') return 'image';
            if (typeof data.value === 'string' && data.value.startsWith('data:image')) return 'image';
            if (data.isCanvas || data.type === 'html') return 'html';
            if (data.type === 'svg' || (typeof data.value === 'string' && data.value.includes('<svg'))) return 'svg';
            return 'text';
        }

        function renderPreviews() {
            if (inputs.length === 0) {
                grid.innerHTML = '';
                grid.appendChild(emptyState);
                emptyState.style.display = 'flex';
                return;
            }

            emptyState.style.display = 'none';
            grid.innerHTML = '';

            inputs.forEach((input, idx) => {
                // Calculate aspect ratio for proper sizing
                const origW = parseInt(input.data.width) || 800;
                const origH = parseInt(input.data.height) || 600;
                const aspect = origW / origH;

                // Size the item to maintain aspect ratio
                const thumbHeight = MAX_THUMB_HEIGHT;
                const thumbWidth = Math.round(thumbHeight * aspect);

                const item = document.createElement('div');
                item.className = `preview-item ${input.selected ? 'selected' : ''}`;
                item.dataset.id = input.id;
                item.style.width = thumbWidth + 'px';
                item.style.height = thumbHeight + 'px';

                // Checkbox
                const checkbox = document.createElement('div');
                checkbox.className = 'checkbox';
                checkbox.innerHTML = '<i class="fas fa-check"></i>';
                item.appendChild(checkbox);

                // Preview Content
                const content = document.createElement('div');
                content.className = 'preview-content';

                if (input.type === 'image') {
                    const img = document.createElement('img');
                    img.src = input.data.value || input.data.dataUrl;
                    img.alt = 'Preview';
                    content.appendChild(img);
                } else if (input.type === 'html' || input.type === 'svg') {
                    const canvas = document.createElement('canvas');
                    canvas.width = thumbWidth * 2;
                    canvas.height = thumbHeight * 2;
                    content.appendChild(canvas);
                    renderThumbnail(input, canvas, origW, origH);
                } else {
                    const text = document.createElement('div');
                    text.style.cssText = 'font-size:8px;color:#888;padding:4px;text-align:center;word-break:break-word;';
                    const val = input.data.value || input.data.content || '';
                    text.textContent = val.substring(0, 50) + (val.length > 50 ? '...' : '');
                    content.appendChild(text);
                }

                item.appendChild(content);

                // Source Name (Editable)
                const sourceName = document.createElement('div');
                sourceName.className = 'source-name';
                sourceName.contentEditable = 'true';
                sourceName.textContent = input.customName || input.sourceTitle;

                sourceName.addEventListener('click', (e) => e.stopPropagation());
                sourceName.addEventListener('blur', () => {
                    const newName = sourceName.textContent.trim();
                    if (newName) input.customName = newName;
                });
                sourceName.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') { e.preventDefault(); sourceName.blur(); }
                });
                item.appendChild(sourceName);

                // Type Badge
                const badge = document.createElement('div');
                badge.className = 'type-badge';
                badge.textContent = input.type;
                item.appendChild(badge);

                // Click handler
                item.addEventListener('click', () => {
                    input.selected = !input.selected;
                    item.classList.toggle('selected', input.selected);
                    updateExportButton();
                    updateSelectAllState();
                });

                grid.appendChild(item);
            });

            updateSelectAllState();
        }

        async function renderThumbnail(input, canvas, origW, origH) {
            try {
                // We just need a fixed off-screen container
                // input.data.value already contains a properly sized wrapper div from Canvas Node
                const container = document.createElement('div');
                container.style.cssText = `
                    position: fixed; left: -9999px; top: 0;
                    width: ${origW}px; height: ${origH}px;
                `;
                container.innerHTML = input.data.value || '';
                document.body.appendChild(container);

                // Find the actual content element (first child or container itself)
                const renderTarget = container.firstElementChild || container;

                const rendered = await html2canvas(renderTarget, {
                    backgroundColor: '#ffffff',
                    scale: 0.25,
                    logging: false,
                    width: origW,
                    height: origH
                });

                document.body.removeChild(container);

                const ctx = canvas.getContext('2d');
                ctx.drawImage(rendered, 0, 0, canvas.width, canvas.height);
            } catch (err) {
                console.warn('[SaveNode] Thumbnail render failed:', err);
            }
        }

        selectAllCheckbox.addEventListener('change', () => {
            inputs.forEach(input => input.selected = selectAllCheckbox.checked);
            renderPreviews();
            updateExportButton();
        });

        function updateSelectAllState() {
            const allSelected = inputs.length > 0 && inputs.every(i => i.selected);
            const someSelected = inputs.some(i => i.selected);
            selectAllCheckbox.checked = allSelected;
            selectAllCheckbox.indeterminate = someSelected && !allSelected;
        }

        formatSelect.addEventListener('change', () => {
            format = formatSelect.value;
            validateFormat();
            window.Mosaic.saveData({ format });
        });

        function validateFormat() {
            const selected = inputs.filter(i => i.selected);
            const hasVisual = selected.some(i => i.type === 'image' || i.type === 'html' || i.type === 'svg');
            if (format === 'txt' && hasVisual) {
                setStatus('Cannot export visual content as TXT', 'error');
                formatSelect.value = 'png';
                format = 'png';
                return false;
            }
            return true;
        }

        function updateExportButton() {
            const selected = inputs.filter(i => i.selected);
            const count = selected.length;
            exportBtn.disabled = count === 0;
            let suffix = '';
            if (count > 1) {
                if (format === 'pdf') suffix = ' as Merged PDF';
                else suffix = ' as ZIP';
            }
            exportBtn.querySelector('span').textContent = `Export Selected (${count})${suffix}`;
        }

        exportBtn.addEventListener('click', async () => {
            if (!validateFormat()) return;
            const selected = inputs.filter(i => i.selected);
            if (selected.length === 0) return;

            setStatus('Preparing export...', '');
            exportBtn.disabled = true;
            exportBtn.innerHTML = '<i class="fas fa-spinner spinner"></i><span>Exporting...</span>';

            try {
                if (format === 'pdf') {
                    // Export as Merged PDF (whether 1 or multiple)
                    await exportAsMergedPDF(selected);
                    setStatus('Exported PDF successfully!', 'success');
                } else if (selected.length === 1) {
                    await exportItem(selected[0], 0);
                    setStatus('Exported successfully!', 'success');
                } else {
                    await exportAsZip(selected);
                    setStatus(`Exported ${selected.length} files as ZIP!`, 'success');
                }
            } catch (err) {
                console.error('[SaveNode] Export error:', err);
                setStatus('Export failed: ' + err.message, 'error');
            } finally {
                exportBtn.disabled = false;
                updateExportButton();
            }
        });

        async function exportAsZip(items) {
            const zip = new JSZip();
            const usedNames = new Set();

            for (let i = 0; i < items.length; i++) {
                setStatus(`Processing ${i + 1} of ${items.length}...`, '');
                const input = items[i];
                let baseName = (input.customName || input.sourceTitle).replace(/[^a-zA-Z0-9]/g, '_');

                // Ensure unique filename
                let filename = baseName;
                let counter = 1;
                while (usedNames.has(filename)) {
                    filename = `${baseName}_${counter}`;
                    counter++;
                }
                usedNames.add(filename);

                const fileData = await getExportData(input);
                zip.file(`${filename}.${format}`, fileData.content, { base64: fileData.isBase64 });
            }

            setStatus('Creating ZIP file...', '');
            const zipBlob = await zip.generateAsync({ type: 'blob' });

            const url = URL.createObjectURL(zipBlob);
            const a = window.parent.document.createElement('a');
            a.href = url;
            a.download = `mosaic-export-${Date.now()}.zip`;
            window.parent.document.body.appendChild(a);
            a.click();
            window.parent.document.body.removeChild(a);
            URL.revokeObjectURL(url);
            window.parent.document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function exportAsMergedPDF(items) {
            const { jsPDF } = window.jspdf;

            // Determine orientation based on first item
            const firstW = parseInt(items[0].data.width) || 800;
            const firstH = parseInt(items[0].data.height) || 600;
            const orientation = firstW > firstH ? 'l' : 'p';

            // Create PDF matching first item's dimensions (in points?) 
            // Better to use A4 or just fit?
            // "Save As Node" usually implies preserving pixel layout.
            // Converting px to pts: 1px = 0.75pt.
            // Let's create PDF with custom size matching the image.
            const doc = new jsPDF({
                orientation: orientation,
                unit: 'px',
                format: [firstW, firstH]
            });

            for (let i = 0; i < items.length; i++) {
                setStatus(`Processing page ${i + 1} of ${items.length}...`, '');
                if (i > 0) doc.addPage([parseInt(items[i].data.width) || 800, parseInt(items[i].data.height) || 600]);

                const input = items[i];
                // Get image data (PNG/JPG)
                // Use JPG for HTML content to save size? Or PNG for quality? PNG is safer.
                const dataUrl = await getRasterData(input, 'png');

                const w = parseInt(input.data.width) || 800;
                const h = parseInt(input.data.height) || 600;

                // Set page size to current item size (if different)
                // jsPDF methods are complex for changing page size mid-doc in some versions.
                // But setPage(i+1) -> internal?
                // `doc.addPage` takes format.

                doc.addImage(dataUrl, 'PNG', 0, 0, w, h);
            }

            setStatus('Generating PDF...', '');
            doc.save(`mosaic-export-${Date.now()}.pdf`);
        }

        async function getExportData(input) {
            if (format === 'png' || format === 'jpg') {
                const dataUrl = await getRasterData(input, format);
                const base64 = dataUrl.split(',')[1];
                return { content: base64, isBase64: true };
            } else if (format === 'svg') {
                return { content: getSvgContent(input), isBase64: false };
            } else if (format === 'html') {
                return { content: getHtmlContent(input), isBase64: false };
            } else if (format === 'json') {
                return { content: JSON.stringify(input.data, null, 2), isBase64: false };
            } else {
                const tmp = document.createElement('div');
                tmp.innerHTML = input.data.value || input.data.content || '';
                return { content: tmp.textContent || '', isBase64: false };
            }
        }

        async function getRasterData(input, fmt) {
            if (input.type === 'image') {
                let dataUrl = input.data.value || input.data.dataUrl;
                if (fmt === 'jpg') dataUrl = await convertToJPG(dataUrl);
                return dataUrl;
            }
            return await renderToCanvas(input, fmt);
        }

        async function exportItem(input, index) {
            const filename = (input.customName || input.sourceTitle).replace(/[^a-zA-Z0-9]/g, '_');

            if (format === 'png' || format === 'jpg') {
                const dataUrl = await getRasterData(input, format);
                const blob = await dataUrlToBlob(dataUrl);
                triggerBlobDownload(blob, `${filename}.${format}`);
            } else if (format === 'svg') {
                triggerTextDownload(getSvgContent(input), `${filename}.svg`, 'image/svg+xml');
            } else if (format === 'html') {
                triggerTextDownload(getHtmlContent(input), `${filename}.html`, 'text/html');
            } else if (format === 'json') {
                triggerTextDownload(JSON.stringify(input.data, null, 2), `${filename}.json`, 'application/json');
            } else {
                const tmp = document.createElement('div');
                tmp.innerHTML = input.data.value || input.data.content || '';
                triggerTextDownload(tmp.textContent || '', `${filename}.txt`, 'text/plain');
            }
        }

        function getSvgContent(input) {
            let content = input.data.value || '';
            if (!content.includes('<svg')) {
                const w = parseInt(input.data.width) || 800;
                const h = parseInt(input.data.height) || 600;
                content = `<?xml version="1.0"?>\n<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}">\n<foreignObject width="100%" height="100%">\n<div xmlns="http://www.w3.org/1999/xhtml">${content}</div>\n</foreignObject>\n</svg>`;
            }
            return content;
        }

        function getHtmlContent(input) {
            return `<!DOCTYPE html>\n<html><head><meta charset="UTF-8"><title>${input.customName || input.sourceTitle}</title></head>\n<body style="margin:0">\n${input.data.value || ''}\n</body></html>`;
        }

        async function renderToCanvas(input, fmt) {
            const w = parseInt(input.data.width) || 800;
            const h = parseInt(input.data.height) || 600;

            const container = document.createElement('div');
            container.style.cssText = `position:fixed;left:-9999px;top:0;width:${w}px;height:${h}px;`;
            container.innerHTML = input.data.value || '';
            document.body.appendChild(container);

            // Render the actual wrapper div from Canvas (first child)
            const renderTarget = container.firstElementChild || container;

            try {
                const canvas = await html2canvas(renderTarget, {
                    backgroundColor: '#ffffff',
                    scale: 2,
                    logging: false,
                    width: w,
                    height: h
                });
                return canvas.toDataURL(fmt === 'jpg' ? 'image/jpeg' : 'image/png', 0.95);
            } finally {
                document.body.removeChild(container);
            }
        }

        async function convertToJPG(dataUrl) {
            return new Promise(resolve => {
                const img = new Image();
                img.onload = () => {
                    const c = document.createElement('canvas');
                    c.width = img.width; c.height = img.height;
                    const ctx = c.getContext('2d');
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(0, 0, c.width, c.height);
                    ctx.drawImage(img, 0, 0);
                    resolve(c.toDataURL('image/jpeg', 0.95));
                };
                img.onerror = () => resolve(dataUrl);
                img.src = dataUrl;
            });
        }

        async function dataUrlToBlob(dataUrl) {
            return (await fetch(dataUrl)).blob();
        }

        function triggerBlobDownload(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = window.parent.document.createElement('a');
            a.href = url; a.download = filename;
            window.parent.document.body.appendChild(a);
            a.click();
            window.parent.document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function triggerTextDownload(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            triggerBlobDownload(blob, filename);
        }

        function setStatus(msg, type) {
            statusDiv.textContent = msg;
            statusDiv.className = 'status ' + type;
        }

        window.Mosaic.onDataLoaded = (data) => {
            if (data && data.format) {
                format = data.format;
                formatSelect.value = format;
            }
        };
    </script>
</body>

</html>