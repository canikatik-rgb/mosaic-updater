<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <title>Mosaic Artboard Studio Pro</title>
    <!-- Google Fonts: Inter -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <title>Canvas Node</title>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts -->
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=Roboto:wght@400;700&family=Playfair+Display:wght@400;700&family=Montserrat:wght@400;700&family=Open+Sans:wght@400;700&display=swap"
        rel="stylesheet">
    <!-- html2canvas for Export -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

    <style>
        :root {
            --bg-dark: #1e1e1e;
            --bg-panel: #2c2c2c;
            --bg-hover: #3a3a3a;
            --bg-active: #0d99ff20;
            --accent: #0d99ff;
            --text: #e0e0e0;
            --text-muted: #888;
            --border: #444;
            --handle-size: 8px;
            --grid-color: #333;
        }

        * {
            box-sizing: border-box;
            outline: none;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-dark);
            color: var(--text);
            user-select: none;
            height: 100vh;
            display: grid;
            grid-template-columns: 240px 1fr 240px;
            /* Layers | Canvas | Properties */
            grid-template-rows: 40px 1fr;
            /* Toolbar | Content */
        }

        /* --- HEADER / TOOLBAR --- */
        #header {
            grid-column: 1 / -1;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 0 10px;
            z-index: 20;
        }

        .tool-btn {
            width: 32px;
            height: 32px;
            border-radius: 4px;
            border: 1px solid transparent;
            background: transparent;
            color: var(--text);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: all 0.1s;
        }

        .tool-btn:hover {
            background: var(--bg-hover);
        }

        .tool-btn.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .separator {
            width: 1px;
            height: 20px;
            background: var(--border);
            margin: 0 5px;
        }

        /* --- LEFT PANEL (LAYERS) --- */
        #left-panel {
            grid-row: 2;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            padding: 10px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border);
            background: #252525;
        }

        #layers-list {
            flex: 1;
            overflow-y: auto;
            padding: 5px;
        }

        .layer-item {
            display: flex;
            align-items: center;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-bottom: 2px;
            color: #ccc;
        }

        .layer-item:hover {
            background: var(--bg-hover);
        }

        .layer-item.selected {
            background: var(--bg-active);
            color: var(--accent);
            border: 1px solid var(--bg-active);
        }

        .layer-icon {
            width: 20px;
            text-align: center;
            margin-right: 8px;
            font-size: 10px;
            opacity: 0.7;
        }

        /* --- CENTER WORKSPACE --- */
        #workspace {
            grid-row: 2;
            position: relative;
            background-color: #1a1a1a;
            /* Dot Grid Pattern */
            background-image: radial-gradient(var(--grid-color) 1px, transparent 1px);
            background-size: 20px 20px;
            overflow: hidden;
            /* Hide scrollbars, we use custom pan */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #artboard-container {
            padding: 0;
            transform-origin: 0 0;
            /* Transform from top-left */
            will-change: transform;
            position: absolute;
            top: 0;
            left: 0;
        }

        #artboard {
            width: 800px;
            height: 600px;
            background: white;
            position: relative;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        /* --- RIGHT PANEL (PROPERTIES) --- */
        #properties {
            grid-row: 2;
            background: var(--bg-panel);
            border-left: 1px solid var(--border);
            padding: 0;
            overflow-y: auto;
        }

        .prop-section {
            padding: 12px;
            border-bottom: 1px solid var(--border);
        }

        .prop-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 8px;
        }

        .prop-row:last-child {
            margin-bottom: 0;
        }

        label {
            font-size: 11px;
            color: var(--text-muted);
            flex: 1;
        }

        input {
            background: #1a1a1a;
            border: 1px solid #444;
            color: white;
            padding: 4px 6px;
            border-radius: 3px;
            font-size: 11px;
            width: 60px;
            text-align: right;
        }

        input:focus {
            border-color: var(--accent);
        }

        input[type="color"] {
            padding: 0;
            width: 30px;
            height: 24px;
            cursor: pointer;
        }

        input[type="text"] {
            width: 100%;
            text-align: left;
        }

        .btn-full {
            width: 100%;
            background: #333;
            border: 1px solid #444;
            color: #ddd;
            padding: 6px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }

        .btn-full:hover {
            background: #444;
        }

        .coord-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .coord-item {
            position: relative;
        }

        .coord-item span {
            position: absolute;
            left: 6px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: #666;
            pointer-events: none;
        }

        .coord-item input {
            padding-left: 20px;
            width: 100%;
        }

        /* --- TRANSFORMER (SELECTION BOX) --- */
        #transformer {
            position: absolute;
            border: 1px solid var(--accent);
            pointer-events: none;
            display: none;
            z-index: 1000;
            box-sizing: border-box;
        }

        .handle {
            width: var(--handle-size);
            height: var(--handle-size);
            background: white;
            border: 1px solid var(--accent);
            position: absolute;
            pointer-events: auto;
            z-index: 1001;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        /* Handle Positions */
        .h-tl {
            top: -5px;
            left: -5px;
            cursor: nwse-resize;
        }

        .h-tr {
            top: -5px;
            right: -5px;
            cursor: nesw-resize;
        }

        .h-bl {
            bottom: -5px;
            left: -5px;
            cursor: nesw-resize;
        }

        .h-br {
            bottom: -5px;
            right: -5px;
            cursor: nwse-resize;
        }

        /* Edge Handles */
        .h-t {
            top: -5px;
            left: 50%;
            margin-left: -4px;
            cursor: ns-resize;
        }

        .h-r {
            top: 50%;
            right: -5px;
            margin-top: -4px;
            cursor: ew-resize;
        }

        .h-b {
            bottom: -5px;
            left: 50%;
            margin-left: -4px;
            cursor: ns-resize;
        }

        .h-l {
            top: 50%;
            left: -5px;
            margin-top: -4px;
            cursor: ew-resize;
        }

        /* --- CANVAS ELEMENTS CSS --- */
        .artboard-el {
            position: absolute;
            box-sizing: border-box;
            /* Includes border in W/H */
        }



        /* Helper to hide UI when empty */
        .empty-state {
            padding: 20px;
            text-align: center;
            color: #555;
            font-size: 12px;
            font-style: italic;
        }

        /* --- VIEW MODE (Thumbnail/Screensaver) --- */
        /* Simple overlay approach - no layout changes */
        body.view-mode::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1a1a1a;
            z-index: 100;
        }

        body.view-mode #workspace {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 101;
            background: #1a1a1a;
        }

        body.view-mode #artboard {
            box-shadow: none;
        }

        /* Keep panels but under overlay (for layout stability) */
        body.view-mode #header,
        body.view-mode #left-panel,
        body.view-mode #properties {
            z-index: 1;
        }
    </style>
</head>

<body>

    <!-- TOP TOOLBAR -->
    <div id="header">
        <button class="tool-btn active" id="tool-select" title="Seçim (V)"><i class="fas fa-arrow-pointer"></i></button>
        <div class="separator"></div>
        <button class="tool-btn" id="tool-rect" title="Dikdörtgen (R)"><i class="far fa-square"></i></button>
        <button class="tool-btn" id="tool-circle" title="Daire (O)"><i class="far fa-circle"></i></button>
        <button class="tool-btn" id="tool-star" title="Yıldız (S)"><i class="fas fa-star"></i></button>
        <div class="separator"></div>
        <button class="tool-btn" id="tool-brush" title="Fırça (B)"><i class="fas fa-pencil-alt"></i></button>
        <button class="tool-btn" id="tool-text" title="Metin (T)"><i class="fas fa-font"></i></button>
        <div class="separator"></div>
        <button class="tool-btn" id="action-front" title="Öne Getir"><i class="fas fa-layer-group"></i></button>
        <button class="tool-btn" id="action-back" title="Arkaya Gönder"><i
                class="fas fa-layer-group fa-flip-vertical"></i></button>
        <div style="flex:1"></div>
        <div class="tool-btn" id="tool-snapshot" title="Export as Image (Send to Save Node)"><i
                class="fas fa-camera"></i></div>
        <button class="tool-btn" id="action-clear" title="Tümünü Sil"><i class="fas fa-trash"></i></button>
    </div>

    <!-- LEFT PANEL: LAYERS -->
    <div id="left-panel">
        <div class="panel-header">Katmanlar</div>
        <div id="layers-list">
            <div class="empty-state">Henüz katman yok</div>
        </div>
    </div>

    <!-- CENTER: CANVAS -->
    <div id="workspace">
        <div id="artboard-container">
            <div id="artboard">
                <!-- Objects go here -->

                <!-- Transformer lives INSIDE artboard to move with scroll/zoom relatively easier -->
                <div id="transformer">
                    <div class="handle h-tl" data-dir="tl"></div>
                    <div class="handle h-t" data-dir="t"></div>
                    <div class="handle h-tr" data-dir="tr"></div>
                    <div class="handle h-r" data-dir="r"></div>
                    <div class="handle h-br" data-dir="br"></div>
                    <div class="handle h-b" data-dir="b"></div>
                    <div class="handle h-bl" data-dir="bl"></div>
                    <div class="handle h-l" data-dir="l"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- RIGHT PANEL: PROPERTIES -->
    <div id="properties">
        <div class="panel-header">Özellikler</div>

        <div id="props-content" style="display:none;">
            <!-- Align / Transform -->
            <div class="prop-section">
                <div class="coord-group">
                    <div class="coord-item"><span>X</span><input type="number" id="inp-x"></div>
                    <div class="coord-item"><span>Y</span><input type="number" id="inp-y"></div>
                    <div class="coord-item"><span>W</span><input type="number" id="inp-w"></div>
                    <div class="coord-item"><span>H</span><input type="number" id="inp-h"></div>
                </div>
                <!-- Angle (Mock) -->
                <div class="prop-row" style="margin-top:8px;">
                    <label>Açı</label>
                    <input type="number" value="0" disabled title="Henüz aktif değil"> °
                </div>
            </div>

            <!-- Appearance -->
            <div class="prop-section">
                <div class="prop-row">
                    <label>Dolgu (Fill)</label>
                    <input type="color" id="inp-fill">
                </div>
                <div class="prop-row">
                    <label>Opaklık</label>
                    <input type="number" id="inp-opacity" min="0" max="100" step="10"> %
                </div>
            </div>

            <!-- Stroke -->
            <div class="prop-section">
                <div class="prop-row">
                    <label>Kenarlık</label>
                    <input type="color" id="inp-border-color">
                </div>
                <div class="prop-row">
                    <label>Kalınlık</label>
                    <input type="number" id="inp-border-width" min="0">
                </div>
                <div class="prop-row">
                    <label>Köşe (Radius)</label>
                    <input type="number" id="inp-radius" min="0">
                </div>
            </div>

            <!-- Text Specific -->
            <div id="group-text" style="display:none; border-top: 1px solid #444; margin-top: 10px; padding-top: 10px;">
                <label>Content</label>
                <textarea id="inp-text-content" rows="3"></textarea>

                <div class="row">
                    <div class="col">
                        <label>Size</label>
                        <input type="number" id="inp-font-size" value="16">
                    </div>
                    <div class="col">
                        <label>Font</label>
                        <div style="display:flex; gap:5px;">
                            <select id="inp-font-family" style="flex:1;">
                                <option value="Inter, sans-serif">Inter</option>
                                <option value="Roboto, sans-serif">Roboto</option>
                                <option value="'Open Sans', sans-serif">Open Sans</option>
                                <option value="Montserrat, sans-serif">Montserrat</option>
                                <option value="'Playfair Display', serif">Playfair (Serif)</option>
                                <option value="Arial, sans-serif">Arial</option>
                                <option value="'Courier New', monospace">Courier</option>
                            </select>
                            <button id="btn-load-font" class="tool-btn" title="Load Local Font"
                                style="width:24px; padding:0;">
                                <i class="fas fa-upload" style="font-size:10px;"></i>
                            </button>
                            <input type="file" id="inp-font-file" accept=".ttf,.otf,.woff,.woff2" style="display:none;">
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div id="props-empty" class="empty-state">
            <div style="font-weight:600; margin-bottom:10px; color:#ddd;">Artboard Ayarları</div>

            <div class="prop-section" style="text-align:left; border:none; padding:0;">
                <div class="prop-row">
                    <label>Boyutlar</label>
                </div>
                <div class="coord-group">
                    <div class="coord-item"><span>W</span><input type="number" id="canvas-w" value="800"></div>
                    <div class="coord-item"><span>H</span><input type="number" id="canvas-h" value="600"></div>
                </div>

                <div class="prop-row" style="margin-top:10px;">
                    <label>Hazır Ayar</label>
                </div>
                <div class="prop-row">
                    <select id="canvas-preset"
                        style="width:100%; background:#1a1a1a; color:white; border:1px solid #444; padding:4px; border-radius:3px; outline:none;">
                        <option value="custom">Custom</option>
                        <option value="1920x1080">Full HD (1920x1080)</option>
                        <option value="1080x1920">Story (1080x1920)</option>
                        <option value="1080x1080">Instagram (1080x1080)</option>
                        <option value="1280x720">HD (1280x720)</option>
                        <option value="800x600">Standard (800x600)</option>
                        <option value="595x842">A4 Dikey</option>
                        <option value="842x595">A4 Yatay</option>
                    </select>
                </div>
            </div>
        </div>
    </div>

    <!-- MOSAIC SDK -->
    <script src="../../js/MosaicNode.js"></script>

    <script>
        /**
         * MOSAIC ARTBOARD PRO LOGIC
         */

        const artboard = document.getElementById('artboard');
        const transformer = document.getElementById('transformer');

        // App State
        const state = {
            tool: 'select', // select, rect, circle, text
            selectedEl: null,
            isDragging: false,
            isResizing: false,
            isDrawing: false,
            resizeDir: null,
            startX: 0, startY: 0,
            startRect: {}, // x, y, w, h
            clipboard: null,
            viewport: { x: 0, y: 0, scale: 1 }
        };

        // Initialize Viewport (Center)
        function centerArtboard() {
            const container = document.getElementById('workspace');
            const ab = document.getElementById('artboard');

            // Initial center
            state.viewport.x = (container.clientWidth - ab.offsetWidth) / 2;
            state.viewport.y = (container.clientHeight - ab.offsetHeight) / 2;
            updateViewport();
        }

        // Wait for layout
        setTimeout(centerArtboard, 100);
        window.addEventListener('resize', () => {
            // Optional: re-center or keep relative? Keep current for now.
        });

        function updateViewport() {
            const el = document.getElementById('artboard-container');
            el.style.transform = `translate(${state.viewport.x}px, ${state.viewport.y}px) scale(${state.viewport.scale})`;
        }

        // --- ZOOM & PAN (Wheel) ---

        function constrainViewport() {
            const container = document.getElementById('workspace');
            const ab = document.getElementById('artboard');
            const margin = 50; // Visible margin

            // Bounds calculation:
            // Artboard visual edges: x, x + width*scale
            // We want at least 'margin' px of artboard to be inside container

            // Min X: Container Right - Margin
            // Max X: Margin - Artboard Width * Scale
            // Actually, we usually want: 
            // x < containerWidth - margin
            // x > margin - artboardWidth * scale

            const abWidth = ab.offsetWidth * state.viewport.scale;
            const abHeight = ab.offsetHeight * state.viewport.scale;

            const minX = margin - abWidth;
            const maxX = container.clientWidth - margin;
            const minY = margin - abHeight;
            const maxY = container.clientHeight - margin;

            state.viewport.x = Math.max(minX, Math.min(state.viewport.x, maxX));
            state.viewport.y = Math.max(minY, Math.min(state.viewport.y, maxY));
        }

        document.getElementById('workspace').addEventListener('wheel', (e) => {
            e.preventDefault();

            // Ctrl/Cmd + Wheel = ZOOM
            // Ctrl/Cmd + Wheel = ZOOM
            if (e.ctrlKey || e.metaKey) {
                // Multiplicative Zoom (matches Mosaic main canvas)
                const zoomFactor = 1 - e.deltaY * 0.01;
                const newScale = Math.min(Math.max(0.1, state.viewport.scale * zoomFactor), 5);

                const rect = document.getElementById('workspace').getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Create World vector from mouse position using OLD scale
                const worldX = (mouseX - state.viewport.x) / state.viewport.scale;
                const worldY = (mouseY - state.viewport.y) / state.viewport.scale;

                // Calculate NEW viewport position to keep mouse at same World coordinates
                state.viewport.x = mouseX - worldX * newScale;
                state.viewport.y = mouseY - worldY * newScale;
                state.viewport.scale = newScale;

                constrainViewport();

            } else {
                // Regular Wheel = PAN
                state.viewport.x -= e.deltaX;
                state.viewport.y -= e.deltaY;
                constrainViewport();
            }

            updateViewport();
        }, { passive: false });

        // --- SPACE + DRAG PANNING ---
        let isSpacePanning = false;
        let lastPanX, lastPanY;

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !isSpacePanning) {
                document.body.style.cursor = 'grab';
            }
        });
        window.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                document.body.style.cursor = 'default';
                isSpacePanning = false; // Cancel if key released
            }
        });

        document.getElementById('workspace').addEventListener('mousedown', (e) => {
            // Middle click or Space+LeftClick
            if (e.button === 1 || (e.button === 0 && document.body.style.cursor === 'grab')) {
                isSpacePanning = true;
                lastPanX = e.clientX;
                lastPanY = e.clientY;
                document.body.style.cursor = 'grabbing';
                e.preventDefault(); // Prevent text selection etc
            }
        });

        function clientToWorld(clientX, clientY) {
            const rect = document.getElementById('workspace').getBoundingClientRect();
            const mouseX = clientX - rect.left;
            const mouseY = clientY - rect.top;

            const worldX = (mouseX - state.viewport.x) / state.viewport.scale;
            const worldY = (mouseY - state.viewport.y) / state.viewport.scale;
            return { x: worldX, y: worldY };
        }

        window.addEventListener('mousemove', (e) => {
            // 1. PANNING
            if (isSpacePanning) {
                const dx = e.clientX - lastPanX;
                const dy = e.clientY - lastPanY;
                lastPanX = e.clientX;
                lastPanY = e.clientY;

                state.viewport.x += dx;
                state.viewport.y += dy;
                constrainViewport();
                updateViewport();
                return;
            }

            // 2. CANVAS INTERACTIONS (Draw, Drag, Resize)
            const pos = clientToWorld(e.clientX, e.clientY);
            const mouseX = pos.x;
            const mouseY = pos.y;

            // HANDLE DRAWING
            if (state.isDrawing && state.selectedEl) {
                const w = mouseX - state.startX;
                const h = mouseY - state.startY;

                // Handle negative drawing (dragging left/up)
                const finalX = w < 0 ? mouseX : state.startX;
                const finalY = h < 0 ? mouseY : state.startY;
                const finalW = Math.abs(w);
                const finalH = Math.abs(h);

                state.selectedEl.style.left = finalX + 'px';
                state.selectedEl.style.top = finalY + 'px';
                state.selectedEl.style.width = finalW + 'px';
                state.selectedEl.style.height = finalH + 'px';
            }

            // HANDLE DRAGGING
            else if (state.isDragging && state.selectedEl) {
                const dx = mouseX - state.startX;
                const dy = mouseY - state.startY;

                state.selectedEl.style.left = (state.startRect.x + dx) + 'px';
                state.selectedEl.style.top = (state.startRect.y + dy) + 'px';

                updateTransformer();
            }

            // HANDLE RESIZING
            else if (state.isResizing && state.selectedEl) {
                const dx = mouseX - state.startX;
                const dy = mouseY - state.startY;
                const r = state.startRect; // Original rect before resize

                let newX = r.x, newY = r.y, newW = r.w, newH = r.h;

                // Logic for 8-point resize
                if (state.resizeDir.includes('r')) newW = Math.max(10, r.w + dx);
                if (state.resizeDir.includes('l')) {
                    const delta = Math.min(dx, r.w - 10);
                    newX = r.x + delta;
                    newW = r.w - delta;
                }
                if (state.resizeDir.includes('b')) newH = Math.max(10, r.h + dy);
                if (state.resizeDir.includes('t')) {
                    const delta = Math.min(dy, r.h - 10);
                    newY = r.y + delta;
                    newH = r.h - delta;
                }

                state.selectedEl.style.left = newX + 'px';
                state.selectedEl.style.top = newY + 'px';
                state.selectedEl.style.width = newW + 'px';
                state.selectedEl.style.height = newH + 'px';

                updateTransformer();
                updatePropsUI();
            }
        });

        // --- TOOLBAR & MODES ---
        const tools = {
            'tool-select': 'select',
            'tool-rect': 'rect',
            'tool-circle': 'circle',
            'tool-star': 'star',
            'tool-brush': 'brush',
            'tool-text': 'text'
        };

        Object.keys(tools).forEach(id => {
            document.getElementById(id).addEventListener('click', () => setTool(tools[id]));
        });

        function setTool(tool) {
            state.tool = tool;
            // Update UI
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            const activeBtn = Object.keys(tools).find(k => tools[k] === tool);
            if (activeBtn) document.getElementById(activeBtn).classList.add('active');

            // Cursor
            artboard.style.cursor = tool === 'select' ? 'default' : 'crosshair';

            // If switching to drawing, deselect
            if (tool !== 'select') deselect();
        }

        // --- AUTO-FIT ON IDLE ---
        let savedViewport = null;

        function fitArtboard() {
            const ab = document.getElementById('artboard');

            // In view-mode, workspace covers full window
            const isViewMode = document.body.classList.contains('view-mode');
            const containerW = isViewMode ? window.innerWidth : document.getElementById('workspace').clientWidth;
            const containerH = isViewMode ? window.innerHeight : document.getElementById('workspace').clientHeight;

            const artboardW = ab.offsetWidth;
            const artboardH = ab.offsetHeight;

            const scaleX = containerW / artboardW;
            const scaleY = containerH / artboardH;
            // Use exact fit, no artificial limit
            const scale = Math.min(scaleX, scaleY);

            const x = (containerW - artboardW * scale) / 2;
            const y = (containerH - artboardH * scale) / 2;

            return { x, y, scale };
        }

        function applyFit() {
            if (!document.body.classList.contains('view-mode')) return;
            const fit = fitArtboard();
            state.viewport = fit;
            // No transition during resize for responsiveness
            document.getElementById('artboard-container').style.transition = '';
            updateViewport();
        }

        // Keep content scaled when window (iframe) resizes
        window.addEventListener('resize', applyFit);

        // --- FOCUS-BASED VIEW MODE ---
        // User Feedback: Toggle View Mode based on Focus, not Mouse Hover.

        window.addEventListener('focus', () => {
            // Active / Edit Mode
            if (document.body.classList.contains('view-mode')) {
                document.body.classList.remove('view-mode');

                if (savedViewport) {
                    state.viewport = { ...savedViewport };
                    savedViewport = null;
                    updateViewport();

                    document.getElementById('artboard-container').style.transition = 'transform 0.2s ease-out';
                    setTimeout(() => {
                        document.getElementById('artboard-container').style.transition = '';
                    }, 200);
                }
            }
        });

        window.addEventListener('blur', () => {
            // Inactive / View Mode
            // Only auto-fit if we are not dragging/drawing
            if (state.isDragging || state.isDrawing || state.isResizing) return;

            // If we are already in view mode, ignore
            if (document.body.classList.contains('view-mode')) return;

            savedViewport = { ...state.viewport };

            // Enter View Mode
            document.body.classList.add('view-mode');

            // Wait for layout update, then fit
            requestAnimationFrame(() => {
                const fit = fitArtboard();
                state.viewport = fit;

                // Add transition for smooth entry
                document.getElementById('artboard-container').style.transition = 'transform 0.3s ease-in-out';
                updateViewport();

                // Remove transition after effect so resize is instant
                setTimeout(() => {
                    document.getElementById('artboard-container').style.transition = '';
                }, 300);
            });
        });

        // --- PASTE SUPPORT ---
        window.addEventListener('paste', (e) => {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;

            // Mouse position for paste target (center of screen if unknown)
            // Ideally we track mouse pos, but for now we'll put it in center or offset
            const pasteX = 50;
            const pasteY = 50;

            for (let index in items) {
                const item = items[index];

                if (item.kind === 'file' && item.type.includes('image')) {
                    const blob = item.getAsFile();
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                            // Create Artboard Element
                            const el = document.createElement('div');
                            el.classList.add('artboard-el');
                            // Scale down if huge
                            let w = img.width;
                            let h = img.height;
                            if (w > 500) {
                                const ratio = 500 / w;
                                w = 500;
                                h = h * ratio;
                            }

                            el.style.width = w + 'px';
                            el.style.height = h + 'px';
                            el.style.left = pasteX + 'px';
                            el.style.top = pasteY + 'px';
                            el.style.backgroundImage = `url(${event.target.result})`;
                            el.style.backgroundSize = 'contain';
                            el.style.backgroundRepeat = 'no-repeat';
                            el.style.backgroundPosition = 'center';
                            el.dataset.type = 'image';
                            el.dataset.src = event.target.result; // Save for persistence

                            document.getElementById('artboard').appendChild(el);
                            renderLayersList(); // Update Layer Panel
                            selectElement(el);
                            saveState();
                        };
                        img.src = event.target.result;
                    };
                    reader.readAsDataURL(blob);
                }
                else if (item.kind === 'string' && item.type.includes('text/plain')) {
                    item.getAsString((text) => {
                        if (!text) return;
                        const el = document.createElement('div');
                        el.classList.add('artboard-el');
                        el.dataset.type = 'text';
                        el.innerText = text;

                        el.style.left = pasteX + 'px';
                        el.style.top = (pasteY + 50) + 'px'; // Offset slightly
                        el.style.color = '#e0e0e0';
                        el.style.fontSize = '20px';
                        el.style.whiteSpace = 'nowrap';
                        el.style.width = 'auto'; // let content define width
                        el.style.height = 'auto';

                        document.getElementById('artboard').appendChild(el);
                        renderLayersList(); // Update Layer Panel
                        selectElement(el);
                        saveState();
                    });
                }
            }
        });

        // --- MOUSE EVENTS MAIN LOOP ---

        artboard.addEventListener('mousedown', (e) => {
            // If clicking transformer handles, let them handle it via stopPropagation
            if (e.target.classList.contains('handle')) return;

            const pos = clientToWorld(e.clientX, e.clientY);
            const mouseX = pos.x;
            const mouseY = pos.y;

            // ... (rest of the listeners) ...


            // 1. DRAWING MODE
            if (state.tool !== 'select') {
                state.isDrawing = true;

                // FIX: Save START position in WORLD coordinates for accurate delta
                const startPos = clientToWorld(e.clientX, e.clientY);
                state.startDrawing = { x: startPos.x, y: startPos.y };
                state.startX = startPos.x;
                state.startY = startPos.y;

                // Create Element immediately

                const el = document.createElement('div');
                el.classList.add('artboard-el');
                el.style.left = mouseX + 'px';
                el.style.top = mouseY + 'px';
                el.style.width = '0px';
                el.style.height = '0px';

                // Default Styles
                el.style.backgroundColor = '#cccccc';
                el.style.border = '0px solid #000';

                if (state.tool === 'circle') el.style.borderRadius = '50%';
                if (state.tool === 'star') {
                    // SVG STAR for better Export
                    el.style.backgroundColor = 'transparent';
                    el.innerHTML = `<svg viewBox="0 0 100 100" preserveAspectRatio="none" style="width:100%; height:100%; overflow:visible;">
                        <polygon points="50,0 61,35 98,35 68,57 79,91 50,70 21,91 32,57 2,35 39,35" fill="#f1c40f"></polygon>
                    </svg>`;
                }

                if (state.tool === 'brush') {
                    // BRUSH INIT
                    el.style.backgroundColor = 'transparent';
                    el.style.border = 'none';
                    // Inner SVG
                    el.innerHTML = `<svg width="100%" height="100%" style="overflow:visible;"><path d="" stroke="#000" stroke-width="3" fill="none" stroke-linecap="round" stroke-linejoin="round"></path></svg>`;
                    state.points = [{ x: 0, y: 0 }]; // Relative points
                    state.brushStart = { x: startPos.x, y: startPos.y }; // Absolute start
                }


                if (state.tool === 'text') {
                    el.innerText = 'Metin';
                    el.style.backgroundColor = 'transparent';
                    el.style.fontSize = '20px';
                    el.style.color = '#e0e0e0';
                    el.style.whiteSpace = 'nowrap';
                    el.style.width = 'auto';
                    el.style.height = 'auto';
                    el.dataset.type = 'text';
                    // Text doesn't drag-draw like shapes, it just plops
                    state.isDrawing = false;
                    artboard.appendChild(el);
                    selectElement(el);
                    setTool('select');
                    saveState();
                    return;
                }

                el.dataset.type = state.tool;
                artboard.appendChild(el);
                state.selectedEl = el; // Temp select for drawing
            }

            // 2. SELECTION MODE
            else {
                // Did we click an element?
                const targetEl = e.target.closest('.artboard-el');
                if (targetEl) {
                    // Multi-select Check:
                    // If clicking an unselected element without shift, select only it.
                    // If clicking a selected element, keep selection (to allow dragging group).
                    // If shift clicking, toggle.

                    if (e.shiftKey) {
                        selectElement(targetEl, true);
                    } else {
                        if (!state.selectedElements || !state.selectedElements.includes(targetEl)) {
                            selectElement(targetEl, false);
                        }
                    }

                    state.selectedEl = targetEl; // Sync primary

                    state.isDragging = true;
                    state.startX = e.clientX;
                    state.startY = e.clientY;

                    // Save start positions for ALL selected elements
                    state.dragStartData = state.selectedElements.map(el => ({
                        el: el,
                        x: el.offsetLeft,
                        y: el.offsetTop
                    }));

                    // We don't use single dragOffset anymore, we calculate delta
                } else {
                    // Clicked empty space
                    if (!e.shiftKey) deselect();

                    // Start Box Selection
                    state.isBoxSelecting = true;
                    const pos = clientToWorld(e.clientX, e.clientY);
                    state.boxStart = { x: pos.x, y: pos.y }; // World Coords

                    // Create Marquee Element
                    let marquee = document.getElementById('selection-marquee');
                    if (!marquee) {
                        marquee = document.createElement('div');
                        marquee.id = 'selection-marquee';
                        marquee.style.position = 'absolute';
                        marquee.style.border = '1px dashed #00a8ff';
                        marquee.style.backgroundColor = 'rgba(0, 168, 255, 0.1)';
                        marquee.style.pointerEvents = 'none';
                        marquee.style.zIndex = '9999';
                        document.getElementById('artboard').appendChild(marquee);
                    }
                    marquee.style.display = 'block';
                    marquee.style.left = pos.x + 'px';
                    marquee.style.top = pos.y + 'px';
                    marquee.style.width = '0px';
                    marquee.style.height = '0px';
                }
            }
        });

        window.addEventListener('mousemove', (e) => {
            // 1. PANNING
            if (isSpacePanning) {
                const dx = e.clientX - lastPanX;
                const dy = e.clientY - lastPanY;
                lastPanX = e.clientX;
                lastPanY = e.clientY;

                state.viewport.x += dx;
                state.viewport.y += dy;
                constrainViewport();
                updateViewport();
                return;
            }

            // 1. DRAGGING
            if (state.isDragging && state.dragStartData) {
                const pos = clientToWorld(e.clientX, e.clientY);
                // Calculate Delta in WORLD space
                // StartX/Y were client coords.
                // But we need World delta.
                // Let's use Client delta / scale? 
                // clientToWorld handles scale!
                // Best way: 
                // Current World Pos - Start World Pos.
                // But we saved client startX.

                const startWorld = clientToWorld(state.startX, state.startY);
                const currentWorld = clientToWorld(e.clientX, e.clientY);

                const deltaX = currentWorld.x - startWorld.x;
                const deltaY = currentWorld.y - startWorld.y;

                state.dragStartData.forEach(item => {
                    item.el.style.left = (item.x + deltaX) + 'px';
                    item.el.style.top = (item.y + deltaY) + 'px';
                });

                updateTransformer();
                updatePropsUI();
            }

            // 3. RESIZING ELEMENT
            if (state.isResizing && state.selectedEl) {
                e.preventDefault();
                const pos = clientToWorld(e.clientX, e.clientY);

                const start = state.startRect; // {x, y, w, h}
                const startX = state.startX; // Screen coords? No, we need World Coords for delta
                // Actually transformer logic used e.clientX (Screen).
                // Let's use world delta.

                // We need the World Position of the mouse when Drag started.
                // We didn't save it. We saved e.clientX.
                // Let's calculate delta in World Space.

                // Convert start mouse to world
                const startWorld = clientToWorld(state.startX, state.startY);
                const currentWorld = pos;

                const dx = currentWorld.x - startWorld.x;
                const dy = currentWorld.y - startWorld.y;

                let newW = start.w;
                let newH = start.h;
                let newX = start.x;
                let newY = start.y;

                // Aspect Ratio
                const ratio = start.w / start.h;

                // Logic based on direction
                // Default: Constrained (Preserve Ratio). Shift: Free.
                // User Request: "Her obje ölçekli... serbest için Shift" -> Default = Constrained.
                const isConstrained = !e.shiftKey;

                // Direction mapping: r=right(east), l=left(west), b=bottom(south), t=top(north)
                if (state.resizeDir.includes('r')) newW = start.w + dx;
                if (state.resizeDir.includes('l')) {
                    newW = start.w - dx;
                    newX = start.x + dx;
                }
                if (state.resizeDir.includes('b')) newH = start.h + dy;
                if (state.resizeDir.includes('t')) {
                    newH = start.h - dy;
                    newY = start.y + dy;
                }

                // Apply Constraint
                if (isConstrained) {
                    // Normalize for direction?
                    // Simple approach: Use Width to drive Height (priority to horizontal?)
                    // Or dominant axis.

                    if (state.resizeDir.includes('r') || state.resizeDir.includes('l')) {
                        // Width driven
                        newH = newW / ratio;
                        if (state.resizeDir.includes('t')) newY = start.y + (start.h - newH);
                        // If center? No center resize yet.
                    } else {
                        // Height driven (t or b only)
                        newW = newH * ratio;
                        if (state.resizeDir.includes('l')) newX = start.x + (start.w - newW);
                    }
                }

                if (newW < 10) newW = 10;
                if (newH < 10) newH = 10;

                state.selectedEl.style.width = newW + 'px';
                state.selectedEl.style.height = newH + 'px';
                if (state.resizeDir.includes('w')) state.selectedEl.style.left = newX + 'px';
                if (state.resizeDir.includes('n')) state.selectedEl.style.top = newY + 'px';

                updateTransformer();
                updatePropsUI();
            }

            // 3. SELECTION BOX
            if (state.isBoxSelecting) {
                const pos = clientToWorld(e.clientX, e.clientY);
                const x = Math.min(pos.x, state.boxStart.x);
                const y = Math.min(pos.y, state.boxStart.y);
                const w = Math.abs(pos.x - state.boxStart.x);
                const h = Math.abs(pos.y - state.boxStart.y);

                const marquee = document.getElementById('selection-marquee');
                if (marquee) {
                    marquee.style.left = x + 'px';
                    marquee.style.top = y + 'px';
                    marquee.style.width = w + 'px';
                    marquee.style.height = h + 'px';
                }
            }

            // 4. DRAWING
            if (state.isDrawing) {
                const pos = clientToWorld(e.clientX, e.clientY);

                // BRUSH LOGIC
                if (state.tool === 'brush') {
                    // Update bounding box based on points
                    // This is complex: we stick the div top-left to min X/Y
                    // and width/height to extents.
                    // But simpler for now: Keep div at start, expand w/h.
                    // If going negative (left/up), we shift div and offset points?
                    // Let's do simple path append first, handle bounding box at mouseup? 
                    // No, visual feedback needed.

                    // Simple approach: Div stays at start. SVG overflow: visible.
                    // But then selection box is wrong. 

                    // Let's just track points relative to Start.
                    const dx = pos.x - state.brushStart.x;
                    const dy = pos.y - state.brushStart.y;
                    state.points.push({ x: dx, y: dy });

                    // Update Path
                    const d = state.points.map((p, i) => (i === 0 ? 'M' : 'L') + ` ${p.x} ${p.y}`).join(' ');
                    state.selectedEl.querySelector('path').setAttribute('d', d);

                    // Auto-expand div to cover path
                    // Find min/max
                    let minX = 0, minY = 0, maxX = 0, maxY = 0;
                    state.points.forEach(p => {
                        if (p.x < minX) minX = p.x;
                        if (p.x > maxX) maxX = p.x;
                        if (p.y < minY) minY = p.y;
                        if (p.y > maxY) maxY = p.y;
                    });

                    // Set div geometry
                    // TopLeft of div = Start + Min
                    const divX = state.brushStart.x + minX;
                    const divY = state.brushStart.y + minY;
                    const divW = maxX - minX;
                    const divH = maxY - minY;

                    state.selectedEl.style.left = divX + 'px';
                    state.selectedEl.style.top = divY + 'px';
                    state.selectedEl.style.width = Math.max(1, divW) + 'px';
                    state.selectedEl.style.height = Math.max(1, divH) + 'px';

                    // Re-adjust path points relative to new Div TopLeft
                    // New Point = (Start + OldPoint) - (Start + Min) = OldPoint - Min
                    const adjustedD = state.points.map((p, i) => {
                        return (i === 0 ? 'M' : 'L') + ` ${p.x - minX} ${p.y - minY}`;
                    }).join(' ');
                    state.selectedEl.querySelector('path').setAttribute('d', adjustedD);

                    return;
                }

                // SHAPE LOGIC
                let w = pos.x - state.startDrawing.x;
                let h = pos.y - state.startDrawing.y;

                // CONSTRAINT LOGIC: 
                // Default = Constrained (Square/Circle)
                // Shift = Free (Rectangle/Ellipse)
                const isConstrained = !e.shiftKey;

                if (isConstrained) {
                    // Enforce 1:1 Aspect Ratio
                    // Use the larger dimension to drive size
                    const size = Math.max(Math.abs(w), Math.abs(h));

                    // Preserve direction
                    w = (w < 0 ? -1 : 1) * size;
                    h = (h < 0 ? -1 : 1) * size;
                }

                state.selectedEl.style.width = Math.abs(w) + 'px';
                state.selectedEl.style.height = Math.abs(h) + 'px';
                state.selectedEl.style.left = (w < 0 ? state.startDrawing.x + w : state.startDrawing.x) + 'px';
                state.selectedEl.style.top = (h < 0 ? state.startDrawing.y + h : state.startDrawing.y) + 'px';
            }
        });
        window.addEventListener('mouseup', (e) => {
            if (state.isBoxSelecting) {
                state.isBoxSelecting = false;
                const marquee = document.getElementById('selection-marquee');
                if (marquee) {
                    const mx = parseInt(marquee.style.left);
                    const my = parseInt(marquee.style.top);
                    const mw = parseInt(marquee.style.width);
                    const mh = parseInt(marquee.style.height);
                    marquee.style.display = 'none';

                    const elements = Array.from(artboard.querySelectorAll('.artboard-el'));
                    const selected = [];
                    elements.forEach(el => {
                        const ex = el.offsetLeft;
                        const ey = el.offsetTop;
                        const ew = el.offsetWidth;
                        const eh = el.offsetHeight;
                        if (mx < ex + ew && mx + mw > ex && my < ey + eh && my + mh > ey) {
                            selected.push(el);
                        }
                    });

                    if (selected.length > 0) {
                        if (!e.shiftKey) state.selectedElements = [];
                        selected.forEach(el => {
                            if (!state.selectedElements.includes(el)) state.selectedElements.push(el);
                        });
                        state.selectedEl = state.selectedElements[state.selectedElements.length - 1];
                        updateTransformer();
                        updatePropsUI();
                        renderLayersList();
                    } else {
                        if (!e.shiftKey) deselect();
                    }
                }
            }

            if (state.isDrawing) {
                if (parseInt(state.selectedEl.style.width) < 5) {
                    state.selectedEl.remove();
                    deselect();
                } else {
                    selectElement(state.selectedEl);
                    renderLayersList();
                }
                state.isDrawing = false;
                setTool('select');
                saveState();
            }

            if (state.isDragging || state.isResizing) {
                state.isDragging = false;
                state.isResizing = false;
                updatePropsUI();
                // 4. Restore Selection (optional, usually clear)
                state.selectedEl = null;
                updatePropsUI();

                // Broadcast restored state to connected nodes (Fixes Presentation Sync)
                setTimeout(sendOutput, 500); // Small delay to ensure DOM render
                saveState();
            }
        });

        // --- KEYBOARD SHORTCUTS ---
        window.addEventListener('keydown', (e) => {
            // Deletion
            if ((e.key === 'Delete' || e.key === 'Backspace') && state.selectedEl) {
                // Check if user is typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) return;

                state.selectedEl.remove();
                deselect();
                renderLayersList();
                saveState();
            }
        });

        // --- TRANSFORMER LOGIC ---
        // Setup handles
        document.querySelectorAll('.handle').forEach(h => {
            h.addEventListener('mousedown', (e) => {
                e.stopPropagation(); // Don't trigger drag
                e.preventDefault();

                state.isResizing = true;
                state.resizeDir = h.dataset.dir;
                state.startX = e.clientX;
                state.startY = e.clientY;

                const el = state.selectedEl;
                state.startRect = {
                    x: el.offsetLeft,
                    y: el.offsetTop,
                    w: el.offsetWidth,
                    h: el.offsetHeight
                };
            });
        });

        function updateTransformer() {
            if (!state.selectedElements || state.selectedElements.length === 0) {
                transformer.style.display = 'none';
                return;
            }
            transformer.style.display = 'block';

            // Calculate Union Box
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;

            state.selectedElements.forEach(el => {
                minX = Math.min(minX, el.offsetLeft);
                minY = Math.min(minY, el.offsetTop);
                maxX = Math.max(maxX, el.offsetLeft + el.offsetWidth);
                maxY = Math.max(maxY, el.offsetTop + el.offsetHeight);
            });

            transformer.style.left = minX + 'px';
            transformer.style.top = minY + 'px';
            transformer.style.width = (maxX - minX) + 'px';
            transformer.style.height = (maxY - minY) + 'px';

            // Hide resize handles if multiple elements (simplification for MVP)
            const handles = transformer.querySelectorAll('.handle');
            handles.forEach(h => h.style.display = state.selectedElements.length > 1 ? 'none' : 'block');
        }

        // --- SELECTION SYSTEM ---
        // --- SELECTION SYSTEM ---
        function selectElement(el, toggle = false) {
            if (toggle) {
                const idx = state.selectedElements.indexOf(el);
                if (idx > -1) {
                    state.selectedElements.splice(idx, 1);
                    if (state.selectedElements.length > 0) {
                        state.selectedEl = state.selectedElements[state.selectedElements.length - 1];
                    } else {
                        state.selectedEl = null;
                    }
                } else {
                    state.selectedElements.push(el);
                    state.selectedEl = el;
                }
            } else {
                // Single Select
                state.selectedElements = [el];
                state.selectedEl = el;
            }

            updateTransformer();
            updatePropsUI();
            renderLayersList();

            if (state.selectedEl) highlightLayer(state.selectedEl.id);
        }

        function deselect() {
            state.selectedEl = null;
            state.selectedElements = [];
            updateTransformer();
            document.getElementById('props-content').style.display = 'none';
            document.getElementById('props-empty').style.display = 'block';
            highlightLayer(null);
        }

        // --- LAYERS PANEL ---
        function renderLayersList() {
            const list = document.getElementById('layers-list');
            list.innerHTML = '';

            // We iterate backwards so top elements are top of list
            const elements = Array.from(artboard.querySelectorAll('.artboard-el')).reverse();

            if (elements.length === 0) {
                list.innerHTML = '<div class="empty-state">Henüz katman yok</div>';
                return;
            }

            elements.forEach(el => {
                const item = document.createElement('div');
                item.className = 'layer-item';
                item.dataset.id = el.id;

                // Icon based on type
                let icon = 'fa-square';
                if (el.style.borderRadius === '50%') icon = 'fa-circle';
                if (el.dataset.type === 'text') icon = 'fa-font';
                if (el.dataset.type === 'image') icon = 'fa-image';

                // Name (Type or Text content)
                let name = el.dataset.type || 'Shape';
                if (el.dataset.type === 'text') name = el.innerText.substring(0, 10);

                item.innerHTML = `<i class="fas ${icon} layer-icon"></i> ${name}`;

                item.addEventListener('click', () => {
                    selectElement(el);
                });

                list.appendChild(item);
            });
        }

        function highlightLayer(id) {
            document.querySelectorAll('.layer-item').forEach(item => {
                item.classList.remove('selected');
                if (item.dataset.id === id) item.classList.add('selected');
            });
        }

        // --- PROPERTIES PANEL LOGIC ---

        // ARTBOARD SETTINGS LOGIC
        const canvasW = document.getElementById('canvas-w');
        const canvasH = document.getElementById('canvas-h');
        const canvasPreset = document.getElementById('canvas-preset');

        function updateArtboardSize(w, h) {
            artboard.style.width = w + 'px';
            artboard.style.height = h + 'px';
            canvasW.value = w;
            canvasH.value = h;
            saveState();
            centerArtboard();
        }

        canvasW.addEventListener('change', (e) => updateArtboardSize(e.target.value, canvasH.value));
        canvasH.addEventListener('change', (e) => updateArtboardSize(canvasW.value, e.target.value));

        canvasPreset.addEventListener('change', (e) => {
            const val = e.target.value;
            if (val === 'custom') return;
            const [w, h] = val.split('x');
            updateArtboardSize(w, h);
        });

        // Sync inputs on load
        canvasW.value = parseInt(artboard.style.width) || 800;
        canvasH.value = parseInt(artboard.style.height) || 600;

        // Existing Props Logic ...

        // Define property mappings
        const props = {
            'inp-x': (el, v) => el.style.left = v + 'px',
            'inp-y': (el, v) => el.style.top = v + 'px',
            'inp-w': (el, v) => el.style.width = v + 'px',
            'inp-h': (el, v) => el.style.height = v + 'px',
            'inp-fill': (el, v) => {
                if (el.dataset.type === 'text') el.style.color = v;
                else if (el.dataset.type === 'star') el.querySelector('polygon').setAttribute('fill', v);
                else if (el.dataset.type === 'brush') el.querySelector('path').setAttribute('stroke', v);
                else el.style.backgroundColor = v;
            },
            'inp-opacity': (el, v) => el.style.opacity = v / 100,
            'inp-border-color': (el, v) => el.style.borderColor = v,
            'inp-border-width': (el, v) => el.style.borderWidth = v + 'px',
            'inp-radius': (el, v) => el.style.borderRadius = v + 'px',
            'inp-text-content': (el, v) => el.innerText = v,
            'inp-font-size': (el, v) => el.style.fontSize = v + 'px',
            'inp-font-family': (el, v) => el.style.fontFamily = v
        };

        // Attach listeners
        Object.keys(props).forEach(id => {
            const inp = document.getElementById(id);
            if (!inp) return; // Guard
            inp.addEventListener('input', (e) => {
                if (!state.selectedEl) return;
                props[id](state.selectedEl, e.target.value);
                updateTransformer(); // Size might change
                saveState();
            });
        });

        function updatePropsUI() {
            if (!state.selectedEl) return;
            const el = state.selectedEl;

            document.getElementById('props-empty').style.display = 'none';
            document.getElementById('props-content').style.display = 'block';

            // Basics
            document.getElementById('inp-x').value = parseInt(el.style.left);
            document.getElementById('inp-y').value = parseInt(el.style.top);
            document.getElementById('inp-w').value = parseInt(el.offsetWidth);
            document.getElementById('inp-h').value = parseInt(el.offsetHeight);

            // Style
            const isText = el.dataset.type === 'text';
            let color;
            if (isText) color = el.style.color;
            else if (el.dataset.type === 'star') color = el.querySelector('polygon').getAttribute('fill');
            else if (el.dataset.type === 'brush') color = el.querySelector('path').getAttribute('stroke');
            else color = el.style.backgroundColor;

            document.getElementById('inp-fill').value = rgbToHex(color);
            document.getElementById('inp-opacity').value = (parseFloat(el.style.opacity || 1) * 100);

            // Border
            document.getElementById('inp-border-width').value = parseInt(el.style.borderWidth || 0);
            document.getElementById('inp-border-color').value = rgbToHex(el.style.borderColor || '#000000');
            document.getElementById('inp-radius').value = parseInt(el.style.borderRadius || 0);

            // Text specific
            const grpText = document.getElementById('group-text');
            if (isText) {
                grpText.style.display = 'block';
                document.getElementById('inp-text-content').value = el.innerText;
                document.getElementById('inp-font-size').value = parseInt(el.style.fontSize) || 16;
                document.getElementById('inp-font-family').value = el.style.fontFamily || 'Inter, sans-serif';
            } else {
            }
        }

        // --- LOCAL FONT LOADING ---
        document.getElementById('btn-load-font').addEventListener('click', () => {
            document.getElementById('inp-font-file').click();
        });

        document.getElementById('inp-font-file').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const fontName = file.name.split('.')[0];
            const buffer = await file.arrayBuffer();
            const fontFace = new FontFace(fontName, buffer);

            try {
                await fontFace.load();
                document.fonts.add(fontFace);

                // Add to select
                const select = document.getElementById('inp-font-family');
                const option = document.createElement('option');
                option.value = `"${fontName}", sans-serif`;
                option.textContent = fontName;
                select.appendChild(option);
                select.value = option.value;

                // Apply to selected element
                if (state.selectedEl && state.selectedEl.dataset.type === 'text') {
                    state.selectedEl.style.fontFamily = option.value;
                    saveState();
                }

                // Temporary persistence handling (in-memory specific to this session)
                // Ideally we'd save the font data blob to Mosaic, but that's heavy.
                // For now, this allows working with the font in the current session.
                console.log('Font loaded:', fontName);

            } catch (err) {
                console.error('Failed to load font:', err);
                alert('Font loading failed: ' + err.message);
            }
        });

        // --- PERSISTENCE ---
        function saveState() {
            const ab = document.getElementById('artboard');
            const elements = Array.from(document.querySelectorAll('.artboard-el')).map(el => {
                const data = {
                    type: el.dataset.type,
                    left: el.style.left,
                    top: el.style.top,
                    width: el.style.width,
                    height: el.style.height,
                    backgroundColor: el.style.backgroundColor,
                    innerText: el.innerText,

                    // Style props
                    color: el.style.color,
                    opacity: el.style.opacity,
                    borderWidth: el.style.borderWidth,
                    borderColor: el.style.borderColor,
                    borderRadius: el.style.borderRadius,
                    fontSize: el.style.fontSize,
                    fontFamily: el.style.fontFamily,

                    src: el.dataset.src
                };
                return data;
            });

            // Capture Artboard Size
            const artboardState = {
                width: ab.style.width,
                height: ab.style.height,
                preset: document.getElementById('canvas-preset').value
            };

            const fullState = {
                elements,
                viewport: state.viewport,
                artboard: artboardState
            };

            window.Mosaic.save(fullState);
        }

        window.Mosaic.onDataLoaded = (data) => {
            if (!data) return;

            // 1. Restore Artboard Size
            if (data.artboard) {
                const ab = document.getElementById('artboard');
                if (data.artboard.width) ab.style.width = data.artboard.width;
                if (data.artboard.height) ab.style.height = data.artboard.height;

                // Update Inputs
                document.getElementById('canvas-w').value = parseInt(ab.style.width) || 800;
                document.getElementById('canvas-h').value = parseInt(ab.style.height) || 600;
                if (data.artboard.preset) document.getElementById('canvas-preset').value = data.artboard.preset;

                console.log('[Canvas] Restored artboard size:', data.artboard.width, 'x', data.artboard.height);
            }

            // 2. Restore Viewport (Camera)
            if (data.viewport) {
                state.viewport = data.viewport;
                savedViewport = state.viewport; // Establish baseline
                updateViewport();
                console.log('[Canvas] Restored viewport');
            }

            // 3. Restore Content
            // Priority: structured elements > html string
            const container = document.getElementById('artboard');

            if (data.elements && data.elements.length > 0) {
                container.innerHTML = ''; // Clear default
                // Ensure transformer exists
                if (!document.getElementById('transformer')) {
                    container.appendChild(transformer);
                }

                data.elements.forEach(elData => {
                    const el = document.createElement('div');
                    el.classList.add('artboard-el');
                    el.style.left = elData.left;
                    el.style.top = elData.top;
                    el.style.width = elData.width;
                    el.style.height = elData.height;
                    el.style.backgroundColor = elData.backgroundColor;
                    if (elData.innerText) el.innerText = elData.innerText;

                    if (elData.color) el.style.color = elData.color;
                    if (elData.opacity) el.style.opacity = elData.opacity;
                    if (elData.borderWidth) el.style.borderWidth = elData.borderWidth;
                    if (elData.borderColor) el.style.borderColor = elData.borderColor;
                    if (elData.borderRadius) el.style.borderRadius = elData.borderRadius;
                    if (elData.fontSize) el.style.fontSize = elData.fontSize;
                    if (elData.fontFamily) el.style.fontFamily = elData.fontFamily;

                    el.dataset.type = elData.type;
                    if (elData.src) {
                        el.dataset.src = elData.src;
                        if (elData.type === 'image') {
                            el.style.backgroundImage = `url(${elData.src})`;
                            el.style.backgroundSize = 'contain';
                            el.style.backgroundRepeat = 'no-repeat';
                            el.style.backgroundPosition = 'center';
                        }
                    }

                    container.appendChild(el);
                });
                console.log('[Canvas] Restored from unstructured elements');
            }
            else if (data.html) {
                // Fallback to HTML string
                container.innerHTML = data.html;

                // Check if transformer exists in new content
                if (!document.getElementById('transformer')) {
                    container.appendChild(transformer);
                }
                console.log('[Canvas] Restored from HTML string');
            }

            // 4. Restore Connected Layouts
            if (data.connectedLayouts) {
                window.connectedLayouts = data.connectedLayouts;
                console.log('[Canvas] Restored connected layouts');
            }

            renderLayersList();
        };


        // --- Z-INDEX ACTIONS ---
        document.getElementById('action-front').addEventListener('click', () => {
            if (state.selectedEl) {
                artboard.appendChild(state.selectedEl); // Move to end of DOM = Top
                renderLayersList();
                saveState();
            }
        });
        document.getElementById('action-back').addEventListener('click', () => {
            if (state.selectedEl) {
                artboard.prepend(state.selectedEl); // Move to start = Bottom
                // Note: This puts it behind transformer? No, transformer is inside artboard but z-indexed high.
                // Actually transformer should be last child always? 
                // Fix: Transformer should stay on top. Let's make transformer a sibling of elements conceptually or use z-index heavily.
                // Current CSS handles z-index, so DOM order affects siblings.
                renderLayersList();
                saveState();
            }
        });
        document.getElementById('action-clear').addEventListener('click', () => {
            if (confirm('Her şeyi silmek istediğine emin misin?')) {
                // Keep transformer, remove others
                document.querySelectorAll('.artboard-el').forEach(e => e.remove());
                deselect();
                renderLayersList();
                saveState();
            }
        });


        // --- SNAPSHOT / EXPORT ---
        document.getElementById('tool-snapshot').addEventListener('click', async () => {
            // Deselect to hide transformer
            deselect();

            const ab = document.getElementById('artboard');

            // Show loading state
            const btn = document.getElementById('tool-snapshot');
            const originalIcon = btn.innerHTML;
            btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';

            try {
                if (typeof html2canvas === 'undefined') {
                    throw new Error('html2canvas library not loaded.');
                }

                // Use html2canvas
                const canvas = await html2canvas(ab, {
                    backgroundColor: null,
                    scale: 2,
                    logging: false,
                    useCORS: true,
                    allowTaint: true, // Fix for tainted canvas
                    ignoreElements: (element) => {
                        // Ignore UI overlays if any remain
                        return element.id === 'transformer' || element.classList.contains('handle');
                    }
                });

                const dataUrl = canvas.toDataURL('image/png');

                // Send as output
                window.Mosaic.send({
                    type: 'image',
                    value: dataUrl,
                    name: (document.title || 'Canvas') + '.png'
                });

                console.log('[Canvas] Snapshot sent!');

                btn.style.color = '#4caf50';
                setTimeout(() => btn.style.color = '', 1000);
            } catch (err) {
                console.error('Snapshot failed:', err);
                alert('Snapshot failed: ' + err.message);
                btn.style.color = 'red';
            } finally {
                btn.innerHTML = originalIcon;
            }
        });

        function sendOutput() {
            const ab = document.getElementById('artboard');
            const fullHTML = ab.innerHTML.replace(/<div id="transformer".*?<\/div>/gs, '');
            // Use style width or offsetWidth as fallback
            const actualWidth = ab.style.width || (ab.offsetWidth + 'px') || '800px';
            const actualHeight = ab.style.height || (ab.offsetHeight + 'px') || '600px';

            const pendingOutput = {
                type: 'html',
                isCanvas: true,
                name: document.title || 'Canvas',
                value: `<div style="position:relative; width:${actualWidth}; height:${actualHeight}; overflow:hidden; background:white;">${fullHTML}</div>`,
                width: actualWidth,
                height: actualHeight
            };

            window.Mosaic.send(pendingOutput);
        }

        // --- UTILS & MOSAIC SYNC ---

        function rgbToHex(col) {
            if (!col || col === 'transparent') return '#000000';
            if (col.startsWith('#')) return col;
            const rgb = col.match(/\d+/g);
            if (!rgb) return '#000000';
            return "#" + ((1 << 24) + (parseInt(rgb[0]) << 16) + (parseInt(rgb[1]) << 8) + parseInt(rgb[2])).toString(16).slice(1);
        }

        // Track if output needs to be sent (dirty flag)
        let pendingOutput = null;
        window.connectedLayouts = {}; // Global store for restored layouts

        function saveState() {
            // Remove transformer for clean HTML export
            transformer.style.display = 'none';

            // Capture layouts of connected elements
            const connectedLayouts = {};
            artboard.querySelectorAll('[data-source-id]').forEach(el => {
                connectedLayouts[el.dataset.sourceId] = {
                    left: el.style.left,
                    top: el.style.top,
                    width: el.style.width,
                    height: el.style.height
                };
            });

            // Clone artboard and remove connected elements (they will be restored via connections)
            const tempArtboard = artboard.cloneNode(true);
            tempArtboard.querySelectorAll('[data-source-id]').forEach(el => el.remove());

            // Also remove the transformer from the clone
            const tempTransformer = tempArtboard.querySelector('#transformer');
            if (tempTransformer) tempTransformer.remove();

            const cleanHTML = tempArtboard.innerHTML;
            transformer.style.display = state.selectedEl ? 'block' : 'none';

            // Save to Mosaic immediately (for persistence)
            // Note: Connected elements are NOT saved as content - they come from source nodes
            // BUT their layout IS saved in connectedLayouts
            // Save to Mosaic immediately
            const ab = document.getElementById('artboard');
            window.Mosaic.saveData({
                html: cleanHTML,
                connectedLayouts: connectedLayouts,
                artboard: {
                    width: ab.style.width,
                    height: ab.style.height,
                    preset: document.getElementById('canvas-preset').value
                }
            });

            // Send updates
            sendOutput();


            // Debounced snapshot for Save Node accuracy
            // Generate image after user stops editing (500ms delay)
            clearTimeout(window._snapshotTimeout);
            window._snapshotTimeout = setTimeout(async () => {
                try {
                    const ab = document.getElementById('artboard');
                    const canvas = await html2canvas(ab, {
                        backgroundColor: '#ffffff',
                        scale: 2,
                        logging: false,
                        useCORS: true,
                        allowTaint: true,
                        ignoreElements: (el) => el.id === 'transformer' || el.classList.contains('handle')
                    });
                    const dataUrl = canvas.toDataURL('image/png');

                    // Send image snapshot for Save Node
                    window.Mosaic.send({
                        type: 'image',
                        value: dataUrl,
                        name: document.title || 'Canvas',
                        width: parseInt(ab.style.width) || 800,
                        height: parseInt(ab.style.height) || 600
                    });
                    console.log('[Canvas] Auto-snapshot sent for Save Node');
                } catch (e) {
                    console.warn('[Canvas] Auto-snapshot failed:', e);
                }
            }, 500);
        }

        // Load
        // onDataLoaded merged above.

        // External Input
        window.Mosaic.on('input', (data, sourceId) => {
            console.log('[Canvas] Received input:', data, 'from', sourceId);

            // SDP Compatibility: Unpack payload
            const value = data.payload ? data.payload.value : data.value;
            // Ensure type is consistent (MosaicData type is top-level)
            const type = data.type;

            // "Smart Object" Logic: Try to find existing element from this source
            let el = null;
            if (sourceId) {
                // We use a custom attribute 'data-source-id' to track origin
                el = Array.from(artboard.querySelectorAll('.artboard-el')).find(e => e.dataset.sourceId === sourceId);
            }

            // A. UPDATE EXISTING (Smart Object) - Completely replace content
            if (el) {
                // Preserve position
                // Preserve position
                const pWidth = data.payload ? data.payload.width : data.width;
                const pHeight = data.payload ? data.payload.height : data.height;

                const width = pWidth ? pWidth + 'px' : el.style.width || '200px';
                const height = pHeight ? pHeight + 'px' : el.style.height || '150px';

                // Reset element
                el.innerHTML = '';
                el.style.backgroundImage = '';
                el.style.width = width;
                el.style.height = height;
                el.dataset.type = type;

                // Apply new content based on type
                if (type === 'text') {
                    el.style.width = 'auto';
                    el.style.height = 'auto';
                    el.innerText = value;
                }
                else if (type === 'image') {
                    el.style.backgroundImage = `url('${value || data.dataUrl}')`;
                    el.style.backgroundSize = 'contain';
                    el.style.backgroundRepeat = 'no-repeat';
                    el.style.backgroundPosition = 'center';
                }
                else if (type === 'svg') {
                    el.innerHTML = value;
                    el.style.width = 'fit-content';
                    el.style.height = 'fit-content';
                }
                else if (type === 'html') {
                    el.style.overflow = 'auto';
                    el.innerHTML = value;
                }
                else if (type === 'url') {
                    el.innerHTML = `<iframe src="${value}" style="width:100%;height:100%;border:none;pointer-events:none;"></iframe>`;
                    el.dataset.url = value;
                }

                // Removed outline flash effect per user request

                // If it's selected, update properties panel
                if (state.selectedEl === el) {
                    updatePropsUI();
                }

                console.log('[Canvas] Updated existing element:', data.type, width, height);
            }

            // B. CREATE NEW - Using dimensions from data if available
            else {
                const w = data.width ? data.width + 'px' : null;
                const h = data.height ? data.height + 'px' : null;

                // Determine Position: Use saved layout if available, or default
                let left = '50px';
                let top = '50px';
                let width = w;
                let height = h;

                if (window.connectedLayouts && window.connectedLayouts[sourceId]) {
                    const saved = window.connectedLayouts[sourceId];
                    if (saved.left) left = saved.left;
                    if (saved.top) top = saved.top;
                    if (saved.width) width = saved.width;
                    if (saved.height) height = saved.height;
                } else if (type === 'image') {
                    left = '100px'; top = '100px';
                }

                if (type === 'text') {
                    el = document.createElement('div');
                    el.classList.add('artboard-el');
                    el.style.left = left; el.style.top = top;
                    el.style.color = '#e0e0e0';
                    el.style.fontSize = '20px';
                    el.innerText = value;
                    el.dataset.type = 'text';
                }
                else if (type === 'image') {
                    el = document.createElement('div');
                    el.classList.add('artboard-el');
                    el.style.left = left; el.style.top = top;
                    el.style.width = width || '200px';
                    el.style.height = height || '150px';
                    el.style.backgroundImage = `url('${value || data.dataUrl}')`;
                    el.style.backgroundSize = 'contain';
                    el.style.backgroundRepeat = 'no-repeat';
                    el.style.backgroundPosition = 'center';
                    el.dataset.type = 'image';
                }
                else if (type === 'html') {
                    el = document.createElement('div');
                    el.classList.add('artboard-el');
                    el.style.left = left; el.style.top = top;
                    el.style.width = width || '300px';
                    el.style.height = height || '200px';
                    el.style.backgroundColor = 'white';
                    el.style.overflow = 'auto';
                    el.innerHTML = value;
                    el.dataset.type = 'html';
                }
                else if (type === 'url') {
                    el = document.createElement('div');
                    el.classList.add('artboard-el');
                    el.style.left = left; el.style.top = top;
                    el.style.width = width || '350px';
                    el.style.height = height || '250px';
                    el.style.backgroundColor = 'white';
                    el.style.overflow = 'hidden';
                    el.innerHTML = `<iframe src="${value}" style="width:100%;height:100%;border:none;pointer-events:none;"></iframe>`;
                    el.dataset.type = 'url';
                    el.dataset.url = value;
                }
                else if (type === 'svg') {
                    el = document.createElement('div');
                    el.classList.add('artboard-el');
                    el.style.left = left; el.style.top = top;
                    el.style.width = 'fit-content';
                    el.style.height = 'fit-content';
                    el.innerHTML = value;
                    el.dataset.type = 'svg';
                }

                if (el) {
                    if (sourceId) el.dataset.sourceId = sourceId; // Tag it!
                    artboard.appendChild(el);
                    renderLayersList();
                }
            }

            saveState();
        });

        // Disconnect Handler
        window.Mosaic.on('disconnect', (sourceId) => {
            if (!sourceId) return;

            // Find element with this source ID
            const el = Array.from(artboard.querySelectorAll('.artboard-el')).find(e => e.dataset.sourceId === sourceId);

            if (el) {
                // If it's selected, deselect it first
                if (state.selectedEl === el) {
                    deselect();
                }

                // Remove from DOM
                el.remove();

                // Clear the saved layout for this source (so reconnecting treats it as new)
                if (window.connectedLayouts && window.connectedLayouts[sourceId]) {
                    delete window.connectedLayouts[sourceId];
                    console.log('Cleared saved layout for source:', sourceId);
                }

                // Update layers
                renderLayersList();
                saveState();

                console.log('Removed element from source:', sourceId);
            }
        });

    </script>
</body>

</html>