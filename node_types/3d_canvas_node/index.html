<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Canvas Node</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
        }

        #app {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        /* Toolbar */
        #toolbar {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #16213e;
            border-bottom: 1px solid #0f3460;
        }

        button {
            background: linear-gradient(135deg, #0f3460 0%, #16213e 100%);
            color: #e94560;
            border: 1px solid #0f3460;
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
        }

        button:hover {
            background: linear-gradient(135deg, #1a4a7a 0%, #1e2d50 100%);
            border-color: #e94560;
        }

        button.primary {
            background: linear-gradient(135deg, #e94560 0%, #c92a4e 100%);
            color: white;
            border-color: #e94560;
        }

        button.primary:hover {
            background: linear-gradient(135deg, #ff5a75 0%, #e94560 100%);
        }

        button.active {
            background: linear-gradient(135deg, #4fc3f7 0%, #2196f3 100%);
            color: white;
            border-color: #4fc3f7;
        }

        .spacer {
            flex: 1;
        }

        .divider {
            width: 1px;
            height: 20px;
            background: #0f3460;
        }

        /* Viewport */
        #viewport {
            flex: 1;
            position: relative;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0f0f1a 100%);
        }

        #canvas-container {
            width: 100%;
            height: 100%;
        }

        canvas {
            display: block;
        }

        /* Empty state */
        #empty-state {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #555;
            pointer-events: none;
        }

        #empty-state i {
            font-size: 48px;
            margin-bottom: 12px;
            color: #e94560;
            opacity: 0.5;
        }

        #empty-state p {
            color: #888;
        }

        /* Info bar */
        #info-bar {
            height: 28px;
            background: #16213e;
            border-top: 1px solid #0f3460;
            display: flex;
            align-items: center;
            padding: 0 12px;
            font-size: 11px;
            color: #888;
            gap: 16px;
        }

        #info-bar .label {
            color: #e94560;
        }

        #info-bar .value {
            color: #4fc3f7;
        }

        /* Settings panel */
        #settings-panel {
            position: absolute;
            top: 50px;
            right: 10px;
            background: #16213e;
            border: 1px solid #0f3460;
            border-radius: 8px;
            padding: 12px;
            display: none;
            z-index: 100;
            min-width: 200px;
        }

        #settings-panel.show {
            display: block;
        }

        #settings-panel h4 {
            color: #e94560;
            margin-bottom: 12px;
            font-size: 12px;
        }

        .setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .setting-row label {
            color: #aaa;
            font-size: 11px;
        }

        .setting-row input[type="color"] {
            width: 30px;
            height: 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .setting-row input[type="checkbox"] {
            accent-color: #e94560;
        }

        /* Loading overlay */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #e94560;
            font-size: 14px;
            display: none;
        }

        #loading.show {
            display: block;
        }

        .hidden {
            display: none !important;
        }

        /* Drop zone */
        #viewport.drag-over::after {
            content: 'Drop 3D Model Here';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(233, 69, 96, 0.2);
            border: 3px dashed #e94560;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: #e94560;
            pointer-events: none;
        }

        /* Model list panel */
        #model-list-panel {
            position: absolute;
            top: 50px;
            left: 10px;
            background: #16213e;
            border: 1px solid #0f3460;
            border-radius: 8px;
            padding: 8px;
            z-index: 100;
            min-width: 180px;
            max-height: 300px;
            overflow-y: auto;
        }

        #model-list-panel h4 {
            color: #e94560;
            margin-bottom: 8px;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .model-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 8px;
            background: #0f3460;
            border-radius: 4px;
            margin-bottom: 4px;
            cursor: pointer;
            font-size: 11px;
            color: #aaa;
        }

        .model-item:hover {
            background: #1a4a7a;
        }

        .model-item.selected {
            background: linear-gradient(135deg, #e94560 0%, #764ba2 100%);
            color: white;
        }

        .model-item .name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .model-item .delete-btn {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            padding: 2px 4px;
            font-size: 10px;
        }

        .model-item .delete-btn:hover {
            color: #e94560;
        }

        .model-item.selected .delete-btn {
            color: rgba(255, 255, 255, 0.7);
        }

        .no-models {
            color: #555;
            font-size: 10px;
            text-align: center;
            padding: 8px;
        }
    </style>
</head>

<body>
    <div id="app">
        <div id="toolbar">
            <button id="import-btn" class="primary">
                <i class="fas fa-plus"></i> Add Model
            </button>
            <input type="file" id="file-input" accept=".stl,.glb,.gltf,.obj,.fbx" style="display: none;" multiple>

            <div class="divider"></div>

            <button id="snapshot-btn">
                <i class="fas fa-camera"></i> Snapshot
            </button>

            <button id="live-btn">
                <i class="fas fa-video"></i> Live
            </button>

            <button id="reset-btn">
                <i class="fas fa-undo"></i> Reset
            </button>

            <div class="divider"></div>

            <!-- Transform Mode Buttons -->
            <button id="move-btn" class="active" title="Move (G)">
                <i class="fas fa-arrows-alt"></i>
            </button>
            <button id="rotate-btn" title="Rotate (R)">
                <i class="fas fa-sync-alt"></i>
            </button>
            <button id="scale-btn" title="Scale (S)">
                <i class="fas fa-expand-arrows-alt"></i>
            </button>

            <div class="spacer"></div>

            <button id="settings-btn">
                <i class="fas fa-cog"></i>
            </button>
        </div>

        <div id="viewport">
            <div id="canvas-container"></div>

            <div id="empty-state">
                <i class="fas fa-cube"></i>
                <p>Import a 3D model or drop it here</p>
                <p style="font-size: 10px; margin-top: 8px; opacity: 0.7;">Supports STL, GLB, GLTF, OBJ</p>
            </div>

            <div id="loading">Loading model...</div>

            <div id="settings-panel">
                <h4>⚙ Settings</h4>
                <div class="setting-row">
                    <label>Background</label>
                    <input type="color" id="bg-color" value="#1a1a2e">
                </div>
                <div class="setting-row">
                    <label>Model Color</label>
                    <input type="color" id="model-color" value="#e94560">
                </div>
                <div class="setting-row">
                    <label>Show Grid</label>
                    <input type="checkbox" id="show-grid" checked>
                </div>
                <div class="setting-row">
                    <label>Auto Rotate</label>
                    <input type="checkbox" id="auto-rotate">
                </div>
                <hr style="border-color: #0f3460; margin: 10px 0;">
                <div class="setting-row">
                    <label>Transparent BG</label>
                    <input type="checkbox" id="transparent-bg">
                </div>
                <div class="setting-row">
                    <label>Live FPS</label>
                    <select id="live-fps"
                        style="background:#0f3460;color:#fff;border:none;border-radius:4px;padding:2px 6px;">
                        <option value="5">5 fps</option>
                        <option value="10" selected>10 fps</option>
                        <option value="15">15 fps</option>
                        <option value="30">30 fps</option>
                    </select>
                </div>
            </div>

            <!-- Model List Panel -->
            <div id="model-list-panel">
                <h4><i class="fas fa-cubes"></i> Models</h4>
                <div id="model-list">
                    <div class="no-models">No models loaded</div>
                </div>
            </div>
        </div>

        <div id="info-bar">
            <span><span class="label">Model:</span> <span class="value" id="model-name">None</span></span>
            <span><span class="label">Vertices:</span> <span class="value" id="vertex-count">0</span></span>
            <span><span class="label">Size:</span> <span class="value" id="model-size">-</span></span>
        </div>
    </div>

    <!-- SDK -->
    <script src="../../js/MosaicNode.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/STLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <!-- FBX dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/fflate@0.8.0/umd/index.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FBXLoader.js"></script>

    <script>
        // ========== DOM Elements ==========
        const importBtn = document.getElementById('import-btn');
        const fileInput = document.getElementById('file-input');
        const snapshotBtn = document.getElementById('snapshot-btn');
        const resetBtn = document.getElementById('reset-btn');
        const settingsBtn = document.getElementById('settings-btn');
        const settingsPanel = document.getElementById('settings-panel');
        const viewport = document.getElementById('viewport');
        const canvasContainer = document.getElementById('canvas-container');
        const emptyState = document.getElementById('empty-state');
        const loading = document.getElementById('loading');

        // Info bar elements
        const modelNameEl = document.getElementById('model-name');
        const vertexCountEl = document.getElementById('vertex-count');
        const modelSizeEl = document.getElementById('model-size');

        // Settings elements
        const bgColorInput = document.getElementById('bg-color');
        const modelColorInput = document.getElementById('model-color');
        const showGridInput = document.getElementById('show-grid');
        const autoRotateInput = document.getElementById('auto-rotate');
        const transparentBgInput = document.getElementById('transparent-bg');
        const liveFpsSelect = document.getElementById('live-fps');
        const liveBtn = document.getElementById('live-btn');
        const modelListEl = document.getElementById('model-list');

        // ========== Live Streaming State ==========
        let isLiveStreaming = false;
        let liveStreamInterval = null;

        // ========== Multi-Model State ==========
        const models = new Map(); // id -> { mesh, fileName, format, data, position, rotation, scale, color }
        let selectedModelId = null;
        let modelIdCounter = 0;
        const MAX_MODEL_SIZE = 50 * 1024 * 1024; // 50MB limit for embedding

        // ========== Three.js Setup ==========
        let scene, camera, renderer, controls, transformControls;
        let gridHelper = null;
        let currentTransformMode = 'translate';

        // Transform mode buttons
        const moveBtn = document.getElementById('move-btn');
        const rotateBtn = document.getElementById('rotate-btn');
        const scaleBtn = document.getElementById('scale-btn');

        function initThree() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);

            // Camera
            camera = new THREE.PerspectiveCamera(
                45,
                canvasContainer.clientWidth / canvasContainer.clientHeight,
                0.1,
                1000
            );
            camera.position.set(5, 5, 5);

            // Renderer - with alpha support for transparent background
            renderer = new THREE.WebGLRenderer({
                antialias: true,
                preserveDrawingBuffer: true,
                alpha: true
            });
            renderer.setClearColor(0x000000, 0); // Transparent by default (used when transparentBg is on)
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            canvasContainer.appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Save state when user finishes orbiting/panning/zooming
            controls.addEventListener('end', () => {
                saveState();
                console.log('[3DCanvas] Camera state saved after orbit');
            });

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight2.position.set(-5, -5, -5);
            scene.add(directionalLight2);

            // Grid
            gridHelper = new THREE.GridHelper(10, 10, 0x0f3460, 0x0f3460);
            scene.add(gridHelper);

            // TransformControls for moving/rotating/scaling models
            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('change', () => renderer.render(scene, camera));
            transformControls.addEventListener('dragging-changed', (e) => {
                controls.enabled = !e.value; // Disable orbit when transforming
                if (!e.value) saveState(); // Save when transform ends
            });
            scene.add(transformControls);

            // Start animation
            animate();

            // Handle resize
            window.addEventListener('resize', onResize);
            new ResizeObserver(onResize).observe(canvasContainer);
        }

        function onResize() {
            if (!camera || !renderer) return;
            camera.aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            // Sync OrbitControls autoRotate with checkbox
            controls.autoRotate = autoRotateInput.checked;
            controls.autoRotateSpeed = 2.0;

            controls.update();
            renderer.render(scene, camera);
        }

        // ========== Model Loading ==========
        function loadModel(file) {
            const fileName = file.name;
            const extension = fileName.split('.').pop().toLowerCase();

            loading.classList.add('show');
            emptyState.classList.add('hidden');

            const reader = new FileReader();

            reader.onload = (e) => {
                const buffer = e.target.result;

                // Store base64 for persistence if under 50MB
                let base64Data = null;
                if (file.size <= MAX_MODEL_SIZE) {
                    base64Data = arrayBufferToBase64(buffer);
                } else {
                    console.warn('[3DCanvas] Model exceeds 50MB, will not be persisted');
                }

                try {
                    switch (extension) {
                        case 'stl':
                            loadSTL(buffer, fileName, extension, base64Data);
                            break;
                        case 'glb':
                        case 'gltf':
                            loadGLTF(buffer, fileName, extension, base64Data);
                            break;
                        case 'obj':
                            loadOBJ(buffer, fileName, extension, base64Data);
                            break;
                        case 'fbx':
                            loadFBX(buffer, fileName, extension, base64Data);
                            break;
                        default:
                            alert('Unsupported format: ' + extension);
                            loading.classList.remove('show');
                    }
                } catch (err) {
                    console.error('Load error:', err);
                    alert('Failed to load model: ' + err.message);
                    loading.classList.remove('show');
                }
            };

            reader.readAsArrayBuffer(file);
        }

        // Utility: ArrayBuffer to Base64
        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        // Utility: Base64 to ArrayBuffer
        function base64ToArrayBuffer(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function loadSTL(buffer, fileName, format, base64Data, savedTransform = null) {
            const loader = new THREE.STLLoader();
            const geometry = loader.parse(buffer);

            const material = new THREE.MeshPhongMaterial({
                color: new THREE.Color(modelColorInput.value),
                specular: 0x111111,
                shininess: 100
            });

            const mesh = new THREE.Mesh(geometry, material);
            addModel(mesh, fileName, format, base64Data, savedTransform);
        }

        function loadGLTF(buffer, fileName, format, base64Data, savedTransform = null) {
            const loader = new THREE.GLTFLoader();
            loader.parse(buffer, '', (gltf) => {
                addModel(gltf.scene, fileName, format, base64Data, savedTransform);
            }, (error) => {
                console.error('GLTF error:', error);
                loading.classList.remove('show');
            });
        }

        function loadOBJ(buffer, fileName, format, base64Data, savedTransform = null) {
            const loader = new THREE.OBJLoader();
            const text = new TextDecoder().decode(buffer);
            const model = loader.parse(text);

            // Apply material
            model.traverse((child) => {
                if (child.isMesh) {
                    child.material = new THREE.MeshPhongMaterial({
                        color: new THREE.Color(modelColorInput.value),
                        specular: 0x111111,
                        shininess: 100
                    });
                }
            });

            addModel(model, fileName, format, base64Data, savedTransform);
        }

        function loadFBX(buffer, fileName, format, base64Data, savedTransform = null) {
            const loader = new THREE.FBXLoader();
            try {
                const model = loader.parse(buffer);

                // Apply material if none
                model.traverse((child) => {
                    if (child.isMesh && !child.material) {
                        child.material = new THREE.MeshPhongMaterial({
                            color: new THREE.Color(modelColorInput.value),
                            specular: 0x111111,
                            shininess: 100
                        });
                    }
                });

                addModel(model, fileName, format, base64Data, savedTransform);
            } catch (err) {
                console.error('FBX error:', err);
                alert('Failed to load FBX: ' + err.message);
                loading.classList.remove('show');
            }
        }

        function addModel(mesh, fileName, format, base64Data, savedTransform = null) {
            // Generate unique ID
            const modelId = 'model-' + (++modelIdCounter);

            // Center and scale (only if not restoring from saved state)
            if (!savedTransform) {
                const box = new THREE.Box3().setFromObject(mesh);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());

                mesh.position.sub(center);

                // Scale to fit in view
                const maxDim = Math.max(size.x, size.y, size.z);
                if (maxDim > 0) {
                    const scale = 4 / maxDim;
                    mesh.scale.multiplyScalar(scale);
                }

                // Offset position if we have multiple models
                const modelCount = models.size;
                if (modelCount > 0) {
                    mesh.position.x += modelCount * 3; // Offset each model
                }
            } else {
                // Apply saved transform (restoring from project load)
                if (savedTransform.position) {
                    mesh.position.set(
                        savedTransform.position.x,
                        savedTransform.position.y,
                        savedTransform.position.z
                    );
                }
                if (savedTransform.rotation) {
                    mesh.rotation.set(
                        savedTransform.rotation.x,
                        savedTransform.rotation.y,
                        savedTransform.rotation.z
                    );
                }
                if (savedTransform.scale) {
                    mesh.scale.set(
                        savedTransform.scale.x,
                        savedTransform.scale.y,
                        savedTransform.scale.z
                    );
                }
                console.log('[3DCanvas] Applied saved transform:', savedTransform);
            }

            scene.add(mesh);

            // Count vertices
            let vertexCount = 0;
            mesh.traverse((child) => {
                if (child.geometry) {
                    const pos = child.geometry.attributes.position;
                    if (pos) vertexCount += pos.count;
                }
            });

            // Store model data
            models.set(modelId, {
                mesh: mesh,
                fileName: fileName,
                format: format,
                data: base64Data,
                color: modelColorInput.value,
                vertexCount: vertexCount
            });

            // Select new model
            selectModel(modelId);

            // Update UI
            updateModelList();
            loading.classList.remove('show');

            // Save state
            saveState();
        }

        // ========== Model List UI ==========
        function updateModelList() {
            if (models.size === 0) {
                modelListEl.innerHTML = '<div class="no-models">No models loaded</div>';
                modelNameEl.textContent = 'None';
                vertexCountEl.textContent = '0';
                modelSizeEl.textContent = '-';
                return;
            }

            let html = '';
            models.forEach((data, id) => {
                const selected = id === selectedModelId ? 'selected' : '';
                html += `
                    <div class="model-item ${selected}" data-id="${id}">
                        <span class="name">${data.fileName}</span>
                        <button class="delete-btn" data-id="${id}"><i class="fas fa-trash"></i></button>
                    </div>
                `;
            });
            modelListEl.innerHTML = html;

            // Add click handlers
            modelListEl.querySelectorAll('.model-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    if (!e.target.closest('.delete-btn')) {
                        selectModel(item.dataset.id);
                    }
                });
            });

            modelListEl.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteModel(btn.dataset.id);
                });
            });
        }

        function selectModel(id) {
            selectedModelId = id;

            // Update UI
            modelListEl.querySelectorAll('.model-item').forEach(item => {
                item.classList.toggle('selected', item.dataset.id === id);
            });

            // Update info bar and attach TransformControls
            const data = models.get(id);
            if (data) {
                modelNameEl.textContent = data.fileName;
                vertexCountEl.textContent = data.vertexCount.toLocaleString();

                const box = new THREE.Box3().setFromObject(data.mesh);
                const size = box.getSize(new THREE.Vector3());
                modelSizeEl.textContent = `${size.x.toFixed(1)} × ${size.y.toFixed(1)} × ${size.z.toFixed(1)}`;

                // Attach TransformControls to selected model
                if (transformControls) {
                    transformControls.attach(data.mesh);
                }
            }
        }

        function deleteModel(id) {
            const data = models.get(id);
            if (data) {
                scene.remove(data.mesh);
                models.delete(id);

                // Select another model if available
                if (selectedModelId === id) {
                    const remaining = Array.from(models.keys());
                    selectedModelId = remaining.length > 0 ? remaining[0] : null;
                }

                updateModelList();
                if (selectedModelId) {
                    selectModel(selectedModelId);
                }

                if (models.size === 0) {
                    emptyState.classList.remove('hidden');
                }

                saveState();
            }
        }

        function resetView() {
            camera.position.set(5, 5, 5);
            camera.lookAt(0, 0, 0);
            controls.reset();
        }

        // ========== Snapshot ==========
        // ========== Snapshot ==========
        function takeSnapshot(lowRes = false) {
            if (!renderer || models.size === 0) return;

            // Store original states for transparent mode AND gizmo visibility
            const wasGridVisible = gridHelper.visible;
            const originalBackground = scene.background;
            const wasTransformVisible = transformControls.visible;

            // 1. Hide Gizmos & Background for Clean Output
            if (transparentBgInput.checked) {
                scene.background = null; // Transparent
            }

            // ALWAYS hide grid and transform controls for snapshot
            gridHelper.visible = false;
            transformControls.visible = false;
            // Also detach controls temporarily to hide the handles completely
            transformControls.detach();

            renderer.render(scene, camera);

            let dataUrl;

            if (lowRes) {
                // For live streaming: 4x smaller resolution (1/2 width, 1/2 height)
                const srcCanvas = renderer.domElement;
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = Math.floor(srcCanvas.width / 2);
                tempCanvas.height = Math.floor(srcCanvas.height / 2);
                const ctx = tempCanvas.getContext('2d');
                ctx.drawImage(srcCanvas, 0, 0, tempCanvas.width, tempCanvas.height);
                dataUrl = tempCanvas.toDataURL('image/png', 0.7); // Lower quality too
            } else {
                dataUrl = renderer.domElement.toDataURL('image/png');
            }

            // Restore original states
            gridHelper.visible = wasGridVisible && showGridInput.checked;
            transformControls.visible = wasTransformVisible;

            if (transparentBgInput.checked) {
                if (!originalBackground && bgColorInput.value) {
                    // If it was null but we have a value, restoring it might be tricky if it was actually transparent logic.
                    // But usually originalBackground is what we want.
                }
                scene.background = originalBackground;
            }

            // Re-attach if we had a selection
            if (selectedModelId) {
                const data = models.get(selectedModelId);
                if (data && transformControls.enabled) transformControls.attach(data.mesh);
            }

            // Send to connected nodes
            window.Mosaic.send({
                type: 'image',
                value: dataUrl,
                sourceType: '3d_snapshot'
            });

            console.log('[3DCanvas] Snapshot sent', lowRes ? '(low-res)' : '');
        }

        // ========== Live Streaming ==========
        function startLiveStreaming() {
            if (isLiveStreaming) return;

            const fps = parseInt(liveFpsSelect.value);
            const interval = 1000 / fps;

            isLiveStreaming = true;
            liveBtn.innerHTML = '<i class="fas fa-stop"></i> Stop';
            liveBtn.style.background = 'linear-gradient(135deg, #e94560 0%, #c92a4e 100%)';
            liveBtn.style.color = 'white';

            // Note: Auto-rotate is independent - user can enable it separately in settings
            liveStreamInterval = setInterval(() => {
                takeSnapshot(true); // Use low-res for live streaming
            }, interval);

            console.log(`[3DCanvas] Live streaming started at ${fps} FPS`);
        }

        function stopLiveStreaming() {
            if (!isLiveStreaming) return;

            isLiveStreaming = false;
            liveBtn.innerHTML = '<i class="fas fa-video"></i> Live';
            liveBtn.style.background = '';
            liveBtn.style.color = '';

            if (liveStreamInterval) {
                clearInterval(liveStreamInterval);
                liveStreamInterval = null;
            }

            console.log('[3DCanvas] Live streaming stopped');
        }

        liveBtn.addEventListener('click', () => {
            if (isLiveStreaming) {
                stopLiveStreaming();
            } else {
                if (models.size === 0) {
                    alert('Load a 3D model first!');
                    return;
                }
                startLiveStreaming();
            }
        });

        // Stop streaming when FPS changes
        liveFpsSelect.addEventListener('change', () => {
            if (isLiveStreaming) {
                stopLiveStreaming();
                startLiveStreaming();
            }
        });

        // ========== Settings ==========
        bgColorInput.addEventListener('input', () => {
            scene.background = new THREE.Color(bgColorInput.value);
            saveState();
        });

        modelColorInput.addEventListener('input', () => {
            // Update selected model color
            if (selectedModelId) {
                const data = models.get(selectedModelId);
                if (data && data.mesh) {
                    data.mesh.traverse((child) => {
                        if (child.material) {
                            child.material.color = new THREE.Color(modelColorInput.value);
                        }
                    });
                    data.color = modelColorInput.value;
                }
            }
            saveState();
        });

        showGridInput.addEventListener('change', () => {
            if (gridHelper) {
                gridHelper.visible = showGridInput.checked;
            }
            saveState();
        });

        transparentBgInput.addEventListener('change', () => {
            const isTransparent = transparentBgInput.checked;
            scene.background = isTransparent ? null : new THREE.Color(bgColorInput.value);
            renderer.setClearColor(isTransparent ? 0x000000 : bgColorInput.value, isTransparent ? 0 : 1);
            saveState();
        });

        // ========== Transform Mode Switching ==========
        function setTransformMode(mode) {
            currentTransformMode = mode;
            if (transformControls) {
                transformControls.setMode(mode);
            }

            // Update button states
            moveBtn.classList.toggle('active', mode === 'translate');
            rotateBtn.classList.toggle('active', mode === 'rotate');
            scaleBtn.classList.toggle('active', mode === 'scale');
        }

        moveBtn.addEventListener('click', () => setTransformMode('translate'));
        rotateBtn.addEventListener('click', () => setTransformMode('rotate'));
        scaleBtn.addEventListener('click', () => setTransformMode('scale'));

        // Keyboard shortcuts for transform modes
        document.addEventListener('keydown', (e) => {
            // Skip if typing in input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            switch (e.key.toLowerCase()) {
                case 'g': setTransformMode('translate'); break;
                case 'r': setTransformMode('rotate'); break;
                case 's': setTransformMode('scale'); break;
                case 'delete':
                case 'backspace':
                    if (selectedModelId) deleteModel(selectedModelId);
                    break;
            }
        });

        settingsBtn.addEventListener('click', () => {
            settingsPanel.classList.toggle('show');
        });

        // Close settings when clicking outside
        document.addEventListener('click', (e) => {
            if (!settingsPanel.contains(e.target) && e.target !== settingsBtn) {
                settingsPanel.classList.remove('show');
            }
        });

        // ========== Event Handlers ==========
        importBtn.addEventListener('click', () => fileInput.click());

        fileInput.addEventListener('change', (e) => {
            // Handle multiple files
            for (const file of e.target.files) {
                loadModel(file);
            }
            e.target.value = ''; // Reset for re-import
        });

        snapshotBtn.addEventListener('click', takeSnapshot);
        resetBtn.addEventListener('click', resetView);

        // Drag & Drop
        viewport.addEventListener('dragover', (e) => {
            e.preventDefault();
            viewport.classList.add('drag-over');
        });

        viewport.addEventListener('dragleave', () => {
            viewport.classList.remove('drag-over');
        });

        viewport.addEventListener('drop', (e) => {
            e.preventDefault();
            viewport.classList.remove('drag-over');

            // Handle multiple dropped files
            for (const file of e.dataTransfer.files) {
            }
        });

        // ========== Mosaic Integration ==========
        function saveState() {
            const modelsData = [];
            models.forEach((model, id) => {
                const mesh = model.mesh;
                modelsData.push({
                    id: id,
                    fileName: model.fileName,
                    format: model.format,
                    data: model.data, // base64
                    color: model.color,
                    transform: {
                        position: { x: mesh.position.x, y: mesh.position.y, z: mesh.position.z },
                        rotation: { x: mesh.rotation.x, y: mesh.rotation.y, z: mesh.rotation.z },
                        scale: { x: mesh.scale.x, y: mesh.scale.y, z: mesh.scale.z }
                    }
                });
            });

            const state = {
                models: modelsData,
                settings: {
                    camera: {
                        position: camera.position.toArray(),
                        target: controls.target.toArray()
                    },
                    bgColor: bgColorInput.value,
                    modelColor: modelColorInput.value,
                    showGrid: showGridInput.checked,
                    autoRotate: autoRotateInput.checked,
                    transparentBg: transparentBgInput.checked,
                    liveFps: liveFpsSelect.value
                }
            };

            window.Mosaic.saveData(state);
        }

        window.Mosaic.onDataLoaded = (state) => {
            console.log('[3DCanvas] Loading state:', state);
            if (!state) return;

            // Restore settings
            if (state.settings) {
                const s = state.settings;
                if (s.bgColor) { bgColorInput.value = s.bgColor; renderer.setClearColor(s.bgColor, s.transparentBg ? 0 : 1); }
                if (s.modelColor) modelColorInput.value = s.modelColor;
                if (s.showGrid !== undefined) { showGridInput.checked = s.showGrid; if (gridHelper) gridHelper.visible = s.showGrid; }
                if (s.autoRotate !== undefined) { autoRotateInput.checked = s.autoRotate; }
                if (s.transparentBg !== undefined) { transparentBgInput.checked = s.transparentBg; }
                if (s.liveFps) liveFpsSelect.value = s.liveFps;

                if (scene) {
                    scene.background = s.transparentBg ? null : new THREE.Color(bgColorInput.value);
                }

                if (s.camera) {
                    // Restore Camera Position and Target
                    if (s.camera.position) {
                        camera.position.set(s.camera.position[0], s.camera.position[1], s.camera.position[2]);
                    }
                    if (s.camera.target) {
                        controls.target.set(s.camera.target[0], s.camera.target[1], s.camera.target[2]);
                    }
                    camera.updateProjectionMatrix();
                    controls.update();
                }
            }

            // Restore models
            if (state.models && Array.isArray(state.models)) {
                const loadPromises = state.models.map(m => {
                    return new Promise((resolve) => {
                        if (m.data) {
                            try {
                                const buffer = base64ToArrayBuffer(m.data);
                                const savedTransform = m.transform;

                                switch (m.format) {
                                    case 'stl': loadSTL(buffer, m.fileName, m.format, m.data, savedTransform); break;
                                    case 'glb':
                                    case 'gltf': loadGLTF(buffer, m.fileName, m.format, m.data, savedTransform); break;
                                    case 'obj': loadOBJ(buffer, m.fileName, m.format, m.data, savedTransform); break;
                                    case 'fbx': loadFBX(buffer, m.fileName, m.format, m.data, savedTransform); break;
                                }
                                // Small delay to allow Three.js to parse
                                setTimeout(resolve, 100);
                            } catch (e) {
                                console.error('Error restoring model:', m.fileName, e);
                                resolve();
                            }
                        } else {
                            resolve();
                        }
                    });
                });

                // Trigger auto-snapshot after all models "started" loading + delay
                Promise.all(loadPromises).then(() => {
                    setTimeout(() => {
                        console.log('[3DCanvas] Triggering auto-snapshot after load...');
                        // Force a camera update one last time before snapshot
                        controls.update();
                        takeSnapshot();
                    }, 1500);
                });
            }
        };

        // Handle input from connected nodes (e.g., file path)
        window.Mosaic.on('input', (data, sourceId) => {
            console.log('[3DCanvas] Input received:', data);

            // SDP Unpack - Future proofing
            const payload = data.payload || {};
            const value = payload.value || data.value;
            // Future: Handle model data from other nodes via 'value'
            // For now, this node mainly loads files via UI upload
            // but we ensure it doesn't crash if data is sent.
        });

        // ========== Initialize ==========
        initThree();
    </script>
</body>

</html>